module static-semantics

imports

  signatures/-
  
signature
  constraint generator
    [[ Start ^ (global) ]]
    [[ Import ^ (global, moduleScope) ]]
    [[ Section ^ (moduleScope) ]]
    
    [[ Pattern ^ (ruleScope) ]]
    
    [[ FlowRule ^ (moduleScope) ]]
    [[ FlowExpr ^ (ruleScope) ]]
    [[ ResolutionConstraint ^ (ruleScope) ]]
    
    [[ Property ^ (moduleScope) ]]
    [[ PropType ^ () : type ]]
    
    [[ PropRule ^ (moduleScope) ]]
    [[ PropRuleBody ^ (ruleScope) ]]
    [[ PropRef ^ (ruleScope) ]]
    [[ VarRef ^ (ruleScope) : type ]]
    [[ WhereClause ^ (ruleScope) ]]
  
  name resolution
    namespaces
      Module Property Variable

  types
    Prop(type, type, type)
    Term()
    Map(type, type)
    Set(type)
    Name()
    Origin()

rules

// flowspec

  init ^ (global) :=
    new global.

  [[ Start(module, imports, sections) ^ (global) ]] :=
    Module { module } <- global,
    moduleScope ---> global,
    Module { module } ===> moduleScope,
    Map1 [[ imports ^ (global, moduleScope) ]],
    Map1 [[ sections ^ (moduleScope) ]],
    distinct D(moduleScope)/Module,
    distinct D(moduleScope)/Property,
    new moduleScope.
  
  [[ Import(mod) ^ (global, moduleScope) ]] :=
    Module { mod } -> global,
    Module { mod } |-> d,
    d <=== moduleScope.

  [[ Flow(rules) ^ (moduleScope) ]] :=
    Map1 [[ rules ^ (moduleScope) ]].

  [[ Properties(defs) ^ (moduleScope) ]] :=
    Map1 [[ defs ^ (moduleScope) ]].

  [[ Rules(rules) ^ (moduleScope) ]] :=
    Map1 [[ rules ^ (moduleScope) ]].

// Pattern

  RulePatternMap1 [[ [pattern|patterns] ^ (ruleScope) ]] :=
    RulePattern [[ pattern ^ (ruleScope) ]],
    RulePatternMap1 [[ patterns ^ (ruleScope) ]].
  
  RulePatternMap1 [[ [] ^ (_) ]].

  RulePattern [[ Match(_, patterns) ^ (ruleScope) ]] :=
    RulePatternMap1 [[ patterns ^ (ruleScope) ]].
  
  RulePattern [[ Wildcard() ^ (ruleScope) ]] := true.
  
  RulePattern [[ Var(x) ^ (ruleScope) ]] :=
    Variable { x } <- ruleScope.
  
  RulePattern [[ At(x, pattern) ^ (ruleScope) ]] :=
    Variable { x } <- ruleScope,
    RulePattern [[ pattern ^ (ruleScope) ]].

  WhereClausePatternMap1 [[ [pattern|patterns] ^ (ruleScope) ]] :=
    WhereClausePattern [[ pattern ^ (ruleScope) ]],
    WhereClausePatternMap1 [[ patterns ^ (ruleScope) ]].
  
  WhereClausePatternMap1 [[ [] ^ (_) ]].

  WhereClausePattern [[ Match(_, patterns) ^ (ruleScope) ]] :=
    Map1 [[ patterns ^ (ruleScope) ]].
  
  WhereClausePattern [[ Wildcard() ^ (ruleScope) ]] := true.
  
  WhereClausePattern [[ Var(x) ^ (ruleScope) ]] :=
    Variable { x } -> ruleScope,
    Variable { x } |-> d.
  
  WhereClausePattern [[ At(x, pattern) ^ (ruleScope) ]] :=
    Variable { x } -> ruleScope,
    Variable { x } |-> d,
    WhereClausePattern [[ pattern ^ (ruleScope) ]].

// Flow
  
  [[ FlowRule(pattern, expr) ^ (moduleScope) ]] :=
    ruleScope ---> moduleScope,
    RulePattern [[ pattern ^ (ruleScope) ]],
    Variable { This() } <- ruleScope,
    FlowExpr [[ expr ^ (ruleScope) ]],
    distinct D(ruleScope)/Variable,
    new ruleScope.
  
  [[ FlowRuleWhere(pattern, expr, resCs) ^ (moduleScope) ]] :=
    ruleScope ---> moduleScope,
    RulePattern [[ pattern ^ (ruleScope) ]],
    Variable { This() } <- ruleScope,
    FlowExpr [[ expr ^ (ruleScope) ]],
    Map1 [[ resCs ^ (ruleScope) ]],
    distinct D(ruleScope)/Variable,
    new ruleScope.
  
  [[ ResolvesTo(ref, def) ^ (ruleScope) ]] :=
    Variable { ref } -> ruleScope,
    Variable { ref } |-> d,
    Variable { def } <- ruleScope.
  
  FlowExpr [[ Ref(x) ^ (ruleScope) ]] :=
    Variable { x } -> ruleScope,
    Variable { x } |-> d.
  
  FlowExpr [[ SeqList(x) ^ (ruleScope) ]] :=
    Variable { x } -> ruleScope,
    Variable { x } |-> d.
  
  FlowExpr [[ ParList(x) ^ (ruleScope) ]] :=
    Variable { x } -> ruleScope,
    Variable { x } |-> d.
  
  FlowExpr [[ Loop() ^ (ruleScope) ]] := true.
  
  FlowExpr [[ t@This() ^ (ruleScope) ]] :=
    Variable { t } -> ruleScope,
    Variable { t } |-> d.
  
  FlowExpr [[ Linear(expr1, expr2) ^ (ruleScope) ]] :=
    FlowExpr [[ expr1 ^ (ruleScope) ]],
    FlowExpr [[ expr2 ^ (ruleScope) ]].
  
  FlowExpr [[ Parallel(expr1, expr2) ^ (ruleScope) ]] :=
    FlowExpr [[ expr1 ^ (ruleScope) ]],
    FlowExpr [[ expr2 ^ (ruleScope) ]].

// Properties
  
  [[ Def(name, proptype, dir, kind) ^ (moduleScope) ]] :=
    Property { name } <- moduleScope,
    Property { name } : Prop(ty, dir, kind),
    [[ proptype ^ () : ty ]].
  
  [[ Map(domain, range) ^ () : Map(ty1, ty2) ]] :=
    [[ domain ^ () : ty1 ]],
    [[ range ^ () : ty2 ]].
  
  [[ NameSet() ^ () : Set(Name()) ]] := true.
  [[ OriginSet() ^ () : Set(Origin()) ]] := true.
  [[ SortSet(_) ^ () : Set(Term()) ]] := true.
  
  [[ Name() ^ () : Name() ]] := true.
  [[ Origin() ^ () : Origin() ]] := true.
  [[ Sort(_) ^ () : Term() ]] := true.
  
  [[ NonSet(simple) ^ () : ty ]] :=
    [[ simple ^ () : ty ]].

// Property rules
  
  [[ PropRuleWhere(patterns, bodies, clauses) ^ (moduleScope) ]] :=
    ruleScope ---> moduleScope,
    RulePatternMap1 [[ patterns ^ (ruleScope) ]],
    Variable { This() } <- ruleScope,
    Map1 [[ bodies ^ (ruleScope) ]],
    Map1 [[ clauses ^ (ruleScope) ]],
// TODO: find something else for definitions of multiple patterns. 
//    distinct D(ruleScope)/Variable,
    new ruleScope.

  [[ Command(_, propref) ^ (ruleScope) ]] :=
    [[ propref ^ (ruleScope) ]].
  
  [[ PropRef(prop, ref) ^ (ruleScope) ]] :=
    Property { prop } -> ruleScope,
    Property { prop } |-> d,
    d : Prop(propty, dir_, kind_),
    VarRef [[ ref ^ (ruleScope) : ty1_ ]],
    ReduceType(propty) == SingleRefType().
    // This means:
    //  ( propty == Name()
    //  ; propty == Origin()
    //  ; propty == Term()
    //  ; propty == Set(ty2_)
    //  ; propty == Map(ty3_, Origin()) ).
  
  [[ MapPropRef(prop, ref1, ref2) ^ (ruleScope) ]] :=
    Property { prop } -> ruleScope,
    Property { prop } |-> d,
    d : Prop(Map(ty3_, ty4_), dir_, kind_),
    VarRef [[ ref1 ^ (ruleScope) : ty1_ ]],
    VarRef [[ ref2 ^ (ruleScope) : ty2_ ]].
  
  VarRef [[ VarRef(id) ^ (ruleScope) : Term() ]] :=
    Variable { id } -> ruleScope,
    Variable { id } |-> d.
  
  VarRef [[ t@This() ^ (ruleScope) : Term() ]] :=
    Variable { t } -> ruleScope,
    Variable { t } |-> d.
  
  WhereClauseVarRef [[ VarRef(id) ^ (ruleScope) ]] :=
    Variable { id } <- ruleScope.
  
  WhereClauseVarRef [[ t@This() ^ (ruleScope) : Term() ]] :=
    Variable { t } -> ruleScope,
    Variable { t } |-> d.

  [[ Contains(pattern, ref) ^ (ruleScope) ]] :=
    WhereClausePattern [[ pattern ^ (ruleScope) ]],
    WhereClauseVarRef [[ ref ^ (ruleScope) ]].
