module static-semantics

imports

  signatures/-
  
signature
  constraint generator
    [[ Start ^ (global) ]]
    [[ Imports ^ (global, moduleScope) ]]
    [[ Import ^ (global, moduleScope) ]]
    [[ Section ^ (moduleScope) ]]
    
    [[ Pattern ^ (ruleScope) ]]
    
    [[ FlowRule ^ (moduleScope) ]]
    [[ FlowExpr ^ (ruleScope) ]]
    
    [[ Property ^ (moduleScope) ]]
    [[ PropType ^ () : type ]]
    
    [[ PropRule ^ (moduleScope) ]]
    [[ PropRuleBody ^ (ruleScope) ]]
    [[ PropRef ^ (ruleScope) ]]
    [[ VarRef ^ (ruleScope) : type ]]
    [[ WhereClause ^ (ruleScope) ]]
  
  name resolution
    namespaces
      Module Property Variable

  types
    Prop(type, type, type)
    Term()
    Map(type, type)
    Set(type)
    Name()
    Origin()

rules

// flowspec

  init ^ (global) :=
    new global.

  [[ Start(module, imports, sections) ^ (global) ]] :=
    Module { module } <- global,
    moduleScope ---> global,
    Module { module } ===> moduleScope,
    [[ imports ^ (global, moduleScope) ]],
    Map1 [[ sections ^ (moduleScope) ]],
    new moduleScope.

  [[ NoImports() ^ (global, moduleScope) ]].
  [[ Imports(imports) ^ (global, moduleScope) ]] :=
    Map1 [[ imports ^ (global, moduleScope) ]].
  
  [[ Import(mod) ^ (global, moduleScope) ]] :=
    Module { mod } -> global,
    Module { mod } |-> d,
    d <=== moduleScope.

  [[ Flow(rules) ^ (moduleScope) ]] :=
    Map1 [[ rules ^ (moduleScope) ]].

  [[ Properties(defs) ^ (moduleScope) ]] :=
    Map1 [[ defs ^ (moduleScope) ]].

  [[ Rules(rules) ^ (moduleScope) ]] :=
    Map1 [[ rules ^ (moduleScope) ]].

// Pattern

  [[ Match(_, patterns) ^ (ruleScope) ]] :=
    Map1 [[ patterns ^ (ruleScope) ]].
  
  [[ Wildcard() ^ (ruleScope) ]] := true.
  
  [[ Var(x) ^ (ruleScope) ]] :=
    Variable { x } <- ruleScope.

// Flow
  
  [[ FlowRule(pattern, expr) ^ (moduleScope) ]] :=
    ruleScope ---> moduleScope,
    [[ pattern ^ (ruleScope) ]],
    [[ expr ^ (ruleScope) ]],
    new ruleScope.
  
  [[ Ref(x) ^ (ruleScope) ]] :=
    Variable { x } -> ruleScope,
    Variable { x } |-> d.
  
  [[ Loop() ^ (ruleScope) ]] := true.
  [[ This() ^ (ruleScope) ]]. // := true. not necessary?
  
  [[ Linear(pattern1, pattern2) ^ (ruleScope) ]] :=
    [[ pattern1 ^ (ruleScope) ]],
    [[ pattern2 ^ (ruleScope) ]].
  
  [[ Parallel(pattern1, pattern2) ^ (ruleScope) ]] :=
    [[ pattern1 ^ (ruleScope) ]],
    [[ pattern2 ^ (ruleScope) ]].

// Properties
  
  [[ Def(name, proptype, dir, kind) ^ (moduleScope) ]] :=
    Property { name } <- moduleScope,
    Property { name } : Prop(ty, dir, kind),
    [[ proptype ^ () : ty ]].
  
  [[ Map(simple, range) ^ () : Map(ty1, ty2) ]] :=
    [[ range ^ () : ty2 ]],
    [[ simple ^ () : ty1 ]].
  
  [[ Set(simple) ^ () : Set(ty) ]] :=
    [[ simple ^ () : ty ]].
  
  [[ Name() ^ () : Name() ]] := true.
  [[ Origin() ^ () : Origin() ]] := true.
  [[ Sort(_) ^ () : Term() ]] := true.

// Property rules
  
  [[ PropRuleWhere(pattern, bodies, clauses) ^ (moduleScope) ]] :=
    ruleScope ---> moduleScope,
    [[ pattern ^ (ruleScope) ]],
    Map1 [[ bodies ^ (ruleScope) ]],
    Map1 [[ clauses ^ (ruleScope) ]],
    new ruleScope.

  [[ Command(_, propref) ^ (ruleScope) ]] :=
    [[ propref ^ (ruleScope) ]].
  
  [[ PropRef(prop, ref) ^ (ruleScope) ]] :=
    Property { prop } -> ruleScope,
    Property { prop } |-> d,
    d : Prop(propty, dir_, kind_),
    [[ ref ^ (ruleScope) : ty1_ ]],
    ReduceType(propty) == SingleRefType().
//    ( propty == Name()
//    ; propty == Origin()
//    ; propty == Term()
//    ; propty == Set(ty2_)
//    ; propty == Map(ty3_, Origin()) ).
  
  [[ MapPropRef(prop, ref1, ref2) ^ (ruleScope) ]] :=
    Property { prop } -> ruleScope,
    Property { prop } |-> d,
    d : Prop(Map(ty3_, ty4_), dir_, kind_),
    [[ ref1 ^ (ruleScope) : ty1_ ]],
    [[ ref2 ^ (ruleScope) : ty2_ ]].
  
  [[ VarRef(id) ^ (ruleScope) : Term() ]] :=
    Variable { id } -> ruleScope,
    Variable { id } |-> d.

  [[ Contains(pattern, ref) ^ (ruleScope) ]] :=
    [[ pattern ^ (ruleScope) ]],
    [[ ref ^ (ruleScope) ]].
