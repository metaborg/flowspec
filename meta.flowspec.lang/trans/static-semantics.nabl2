module static-semantics

imports

  signatures/-

signature
  constraint generator
    [[ Start ^ (global) ]]
    [[ Import ^ (global, moduleScope) ]]
    [[ Section ^ (moduleScope) ]]

    [[ Pattern ^ (ruleScope) ]]

    [[ FlowRule ^ (moduleScope) ]]
    [[ FlowExpr ^ (ruleScope) ]]
    [[ FlowNode ^ (ruleScope) ]]
    [[ FlowWhereClause ^ (ruleScope) ]]

    [[ Property ^ (moduleScope) ]]
    [[ PropType ^ () : Type ]]

    [[ PropRule ^ (moduleScope) ]]
    [[ PropRuleBody ^ (ruleScope) ]]
    [[ PropBooleanExpr ^ (ruleScope) ]]
    [[ HasPropExpr ^ (ruleScope) ]]
    [[ VarRef ^ (ruleScope) : Type ]]
    [[ PropWhereClause ^ (ruleScope) ]]

  name resolution
    namespaces
      Module Property Variable

  relations
    anti-symmetric, anti-transitive test : Type * TypeTest

  functions
    propElemType: Type -> RefType {
      Name() -> Name(),
      Origin() -> Origin(),
      Term() -> Term(),
      Set(ty) -> ty,
      Map(ty, ty2) -> (ty, ty2)
    }

  constructors
    Prop: Type * Type * Type -> Type
    Term : Type
    Map : Type * Type -> Type
    Set : Type -> Type
    Name : Type
    Origin : Type

    IsSingle : TypeTest
    IsDual : TypeTest

rules

// flowspec

  init ^ (global) :=
    Name() <test! IsSingle(),
    Origin() <test! IsSingle(),
    Term() <test! IsSingle(),
    (Name(), Origin()) <test! IsSingle(),
    (Origin(), Origin()) <test! IsSingle(),
    (Term(), Origin()) <test! IsSingle(),

    (Name(), Origin()) <test! IsDual(),
    (Origin(), Origin()) <test! IsDual(),
    (Term(), Origin()) <test! IsDual(),
    (Name(), Name()) <test! IsDual(),
    (Origin(), Name()) <test! IsDual(),
    (Term(), Name()) <test! IsDual(),
    (Name(), Term()) <test! IsDual(),
    (Origin(), Term()) <test! IsDual(),
    (Term(), Term()) <test! IsDual(),

    new global.

  [[ Start(module, imports, sections) ^ (global) ]] :=
    Module { module } <- global,
    moduleScope ---> global,
    Module { module } ===> moduleScope,
    Map1 [[ imports ^ (global, moduleScope) ]],
    Map1 [[ sections ^ (moduleScope) ]],
    distinct D(moduleScope)/Module,
    distinct D(moduleScope)/Property,
    new moduleScope.
  
  [[ Import(mod) ^ (global, moduleScope) ]] :=
    Module { mod } -> global,
    Module { mod } |-> d,
    Module { mod } <=== moduleScope.

  [[ Flow(rules) ^ (moduleScope) ]] :=
    Map1 [[ rules ^ (moduleScope) ]].

  [[ Properties(defs) ^ (moduleScope) ]] :=
    Map1 [[ defs ^ (moduleScope) ]].

  [[ Rules(rules) ^ (moduleScope) ]] :=
    Map1 [[ rules ^ (moduleScope) ]].

// Pattern

  RulePatternMap1 [[ [pattern|patterns] ^ (ruleScope) ]] :=
    RulePattern [[ pattern ^ (ruleScope) ]],
    RulePatternMap1 [[ patterns ^ (ruleScope) ]].

  RulePatternMap1 [[ [] ^ (_) ]].

  RulePattern [[ Match(_, patterns) ^ (ruleScope) ]] :=
    RulePatternMap1 [[ patterns ^ (ruleScope) ]].

  RulePattern [[ Wildcard() ^ (ruleScope) ]] := true.

  RulePattern [[ Var(x) ^ (ruleScope) ]] :=
    Variable { x } <- ruleScope.

  RulePattern [[ At(x, pattern) ^ (ruleScope) ]] :=
    Variable { x } <- ruleScope,
    RulePattern [[ pattern ^ (ruleScope) ]].

  WhereClausePatternMap1 [[ [pattern|patterns] ^ (ruleScope) ]] :=
    WhereClausePattern [[ pattern ^ (ruleScope) ]],
    WhereClausePatternMap1 [[ patterns ^ (ruleScope) ]].
  
  WhereClausePatternMap1 [[ [] ^ (_) ]].

  WhereClausePattern [[ Match(_, patterns) ^ (ruleScope) ]] :=
    Map1 [[ patterns ^ (ruleScope) ]].

  WhereClausePattern [[ Wildcard() ^ (ruleScope) ]] := true.

  WhereClausePattern [[ Var(x) ^ (ruleScope) ]] :=
    Variable { x } -> ruleScope,
    Variable { x } |-> d.

  WhereClausePattern [[ At(x, pattern) ^ (ruleScope) ]] :=
    Variable { x } -> ruleScope,
    Variable { x } |-> d,
    WhereClausePattern [[ pattern ^ (ruleScope) ]].

// Flow

  [[ FlowRule(pattern, exprs) ^ (moduleScope) ]] :=
    ruleScope ---> moduleScope,
    RulePattern [[ pattern ^ (ruleScope) ]],
    Variable { Entry() } <- ruleScope,
    Variable { Exit() } <- ruleScope,
    Map1 [[ exprs ^ (ruleScope) ]],
    distinct D(ruleScope)/Variable,
    new ruleScope.

  [[ Recurse(x) ^ (ruleScope) ]] :=
    Variable { x } -> ruleScope,
    Variable { x } |-> d.

  [[ ConditionalEdge(from, to, flowclauses) ^ (ruleScope) ]] :=
    [[ from ^ (ruleScope) ]],
    [[ to ^ (ruleScope) ]],
    Map1 [[ flowclauses ^ (ruleScope) ]].

  [[ Writes(x) ^ (ruleScope) ]] :=
    Variable { x } -> ruleScope,
    Variable { x } |-> d.

  [[ Reads(x) ^ (ruleScope) ]] :=
    Variable { x } -> ruleScope,
    Variable { x } |-> d.

  [[ Ref(x) ^ (ruleScope) ]] :=
    Variable { x } -> ruleScope,
    Variable { x } |-> d.

  [[ e@Entry() ^ (ruleScope) ]] :=
    Variable { e } -> ruleScope.

  [[ e@Exit() ^ (ruleScope) ]] :=
    Variable { e } -> ruleScope.

  [[ HasProp(x, propname, pattern) ^ (ruleScope) ]] :=
    Variable { x } -> ruleScope,
    Variable { x } |-> dX,
    Property { propname } -> ruleScope,
    Property { propname } |-> dPropname,
    WhereClausePattern [[ pattern ^ (ruleScope) ]].

  [[ HasMapProp(x, propname, pattern1, pattern2) ^ (ruleScope) ]] :=
    Variable { x } -> ruleScope,
    Variable { x } |-> dX,
    Property { propname } -> ruleScope,
    Property { propname } |-> dPropname,
    WhereClausePattern [[ pattern1 ^ (ruleScope) ]],
    WhereClausePattern [[ pattern2 ^ (ruleScope) ]].

// Properties

  [[ Def(name, proptype, dir, kind) ^ (moduleScope) ]] :=
    Property { name } <- moduleScope,
    Property { name } : Prop(ty, dir, kind),
    [[ proptype ^ () : ty ]].

  [[ Map(domain, range) ^ () : Map(ty1, ty2) ]] :=
    [[ domain ^ () : ty1 ]],
    [[ range ^ () : ty2 ]].

  [[ NameSet() ^ () : Set(Name()) ]] := true.
  [[ OriginSet() ^ () : Set(Origin()) ]] := true.
  [[ SortSet(_) ^ () : Set(Term()) ]] := true.

  [[ Name() ^ () : Name() ]] := true.
  [[ Origin() ^ () : Origin() ]] := true.
  [[ Sort(_) ^ () : Term() ]] := true.

  [[ NonSet(simple) ^ () : ty ]] :=
    [[ simple ^ () : ty ]].

// Property rules

  [[ PropRuleWhere(pattern, body, whereclause) ^ (moduleScope) ]] :=
    ruleScope ---> moduleScope,
    RulePattern [[ pattern ^ (ruleScope) ]],
    Variable { This() } <- ruleScope,
    [[ body ^ (ruleScope) ]],
    [[ whereclause ^ (ruleScope) ]],
    distinct D(ruleScope)/Variable,
    new ruleScope.

  [[ PropRef(prop, ref) ^ (ruleScope) ]] :=
    Property { prop } -> ruleScope,
    Property { prop } |-> d,
    d : Prop(propty, dir_, kind_),
    VarRef [[ ref ^ (ruleScope) : ty1_ ]],
    elemty is propElemType of propty,
    elemty <test? IsSingle().
    // This means:
    //  ( propty == Name()
    //  ; propty == Origin()
    //  ; propty == Term()
    //  ; propty == Set(ty2_)
    //  ; propty == Map(ty3_, Origin()) ).

  [[ MapPropRef(prop, ref1, ref2) ^ (ruleScope) ]] :=
    Property { prop } -> ruleScope,
    Property { prop } |-> d,
    d : Prop(propty, dir_, kind_),
    elemty is propElemType of propty,
    elemty <test? IsDual(),
    VarRef [[ ref1 ^ (ruleScope) : ty1_ ]],
    VarRef [[ ref2 ^ (ruleScope) : ty2_ ]].

  [[ And(whereclause1, whereclause2) ^ (ruleScope) ]] :=
    [[ whereclause1 ^ (ruleScope) ]],
    [[ whereclause2 ^ (ruleScope) ]].

  [[ CFGArrow(pattern1, pattern2) ^ (ruleScope) ]] :=
  // TODO: is this really the case? Seems more like these are inference variables
    WhereClausePattern [[ pattern1 ^ (ruleScope) ]],
  // TODO: is this really the case? Seems more like these are inference variables
    WhereClausePattern [[ pattern2 ^ (ruleScope) ]].

  [[ HasProp(x, propname, varref) ^ (ruleScope) ]] :=
    Variable { x } -> ruleScope,
    Variable { x } |-> dX,
    Property { propname } -> ruleScope,
    Property { propname } |-> dPropname,
  // TODO: is this really the case? Seems more like these are inference variables
    VarRef [[ varref ^ (ruleScope) ]].

  [[ HasMapProp(x, propname, varref1, varref2) ^ (ruleScope) ]] :=
    Variable { x } -> ruleScope,
    Variable { x } |-> dX,
    Property { propname } -> ruleScope,
    Property { propname } |-> dPropname,
  // TODO: is this really the case? Seems more like these are inference variables
    VarRef [[ varref1 ^ (ruleScope) ]],
  // TODO: is this really the case? Seems more like these are inference variables
    VarRef [[ varref2 ^ (ruleScope) ]].

  VarRef [[ VarRef(id) ^ (ruleScope) : Term() ]] :=
    Variable { id } -> ruleScope,
    Variable { id } |-> d.

  VarRef [[ t@This() ^ (ruleScope) : Term() ]] :=
    Variable { t } -> ruleScope,
    Variable { t } |-> d.

// Currently unused while we figure out what to do with inference variables
//  WhereClauseVarRef [[ VarRef(id) ^ (ruleScope) ]] :=
//    Variable { id } <- ruleScope.
//
//  WhereClauseVarRef [[ t@This() ^ (ruleScope) : Term() ]] :=
//    Variable { t } -> ruleScope,
//    Variable { t } |-> d.
