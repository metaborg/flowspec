module generate

imports

signatures/-

strategies

lines_ = separate-by(|"\n");concat-strings
csv = separate-by(|", ");concat-strings

rules

// flowspec
// flowspec - Start
gen-str: Start(modulename, import*, section*) ->
  ${module {modulename}

  imports

//  flowspec/signatures/-
  libspoofax/stratego/debug
  nabl2/shared/-

  signatures/-
  {importstring}

  // temporary, should be moved to runtime part of the language so it can be imported
  signature constructors
    CFGEdge : Term * Term * List(Term) -> Constraint
    Entry : Condition
    Exit : Condition
    HasProp : Term * Term * Term -> Condition

  strategies

  flowspec--generate-cfg-constraint =
    flowspec--generate-cfg-constraint-rule
    <+ (debug(|"[WARNING] Rule missing for this constructor: ");![])

  rules

  {sectionstring}
}
with importstring := <map(?Import(<id>));lines_> import*
   ; sectionstring := <filter(gen-str);lines_> section*

// flowspec - Section
gen-str: Rules(_) -> <fail>
with <debug> "[NOTE] we're not generating code for the property rules section yet. "

gen-str: Properties(_) -> <fail>
with <debug> "[NOTE] we're not generating code for the properties section yet. "

gen-str: Flow(flowrule*) -> <map(gen-str);lines_> flowrule*

// Flow
// Flow - FlowRule
gen-str: FlowRule(pattern, edge*) ->
  ${flowspec--generate-cfg-constraint-rule:
    this@{patternstring} -> <concat> [{constraintstring}]
  with(index-this := <nabl2--get-ast-index> this)
  {indicesgenerationstring}
  with(constr := [{withclausestring}])
  {subtermconstraintstring}
}
with patternstring := <gen-str> pattern
   ; variables := <pattern-variables> pattern
   ; withclausestring := <map(gen-constraints(|variables));separate-by(|",\n");concat-strings> edge*
   ; constraintstring :=
      <csv> [ "constr" | <map(!$[constr-[<id>]])> variables ]
   ; indicesgenerationstring := <map(gen-index-rule);lines_> variables
   ; subtermconstraintstring := <map(gen-subterm-constraints);lines_> variables

// Flow - FlowExpr
gen-constraints(|variables): ConditionalEdge(Entry(), to@Ref(_), cond*) ->
  ${CFGEdge(index-this, {tostring}, [{condstring}])}
with tostring := <gen-constraints(|variables)> to
   ; condstring := <map(gen-constraints(|variables));!["Entry()"|<id>];csv> cond*
   
gen-constraints(|variables): ConditionalEdge(from@Ref(_), Exit(), cond*) ->
  ${CFGEdge({fromstring}, index-this, [{condstring}])}
with fromstring := <gen-constraints(|variables)> from
   ; condstring := <map(gen-constraints(|variables));!["Exit()"|<id>];csv> cond*
   
gen-constraints(|variables): ConditionalEdge(from@Ref(_), to@Ref(_), cond*) ->
  ${CFGEdge({fromstring}, {tostring}, [{condstring}])}
with fromstring := <gen-constraints(|variables)> from
   ; tostring := <gen-constraints(|variables)> to
   ; condstring := <map(gen-constraints(|variables));csv> cond*

gen-constraints(|variables): Ref(ident) -> $[index-[ident]]
where if <not(member)> (ident, variables)
    then <debug>
      ${[ERROR] Variable {ident} does not come from the AST; this is currently not supported!}
  end

gen-constraints(|variables): HasProp(ident, prop, pattern) ->
  $[HasProp(index-[ident], "[prop]", [patternstring])]
with patternstring := <gen-str> pattern
where if <not(member)> (ident, variables)
    then <debug>
      ${[ERROR] Variable {ident} doesn't come from the AST; this is currently not supported!}
  end
; if <pattern-variables;?idents;not(?[])> pattern
    then <debug>
      ${[ERROR] Matching properties to variables in flow rules is currently not supported!}
  end

gen-index-rule: var ->
  ${with(index-{var} := <nabl2--get-ast-index> flo-{var})}

gen-subterm-constraints: var ->
  ${with(constr-{var} := <flowspec--generate-cfg-constraint> flo-{var})}

// Pattern
// Pattern - Pattern, Wildcard
gen-str: Var(ident) -> $[flo-[ident]]
gen-str: At(ident, pattern) -> $[flo-[ident]@[patternstring]]
with patternstring := <gen-str> pattern
gen-str: Match(consname, subpattern*) -> $[[consname]([subpatternsstring])]
with subpatternsstring := <map(gen-str);csv> subpattern*
gen-str: Wildcard() -> "_"

pattern-variables: Var(ident) -> [ident]
pattern-variables: At(ident, pattern) -> [ ident | <pattern-variables> pattern ]
pattern-variables: Match(_, subpattern*) -> <mapconcat(pattern-variables)> subpattern*
pattern-variables: Wildcard() -> []
