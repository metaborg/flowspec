module flowspec/static-semantics


imports

  signatures/flowspec/-
  flowspec/desugar

signature
  constraint generator
    [[ Module ^ (global) ]]
    [[ Import ^ (global, moduleScope) ]]
    [[ Section ^ (moduleScope) ]]

    [[ Pattern ^ (ruleScope) ]]

    [[ FlowRule ^ (moduleScope) ]]
    [[ FlowExpr ^ (ruleScope) ]]
    [[ FlowNode ^ (ruleScope) ]]
    [[ FlowWhereClause ^ (ruleScope) ]]

    [[ Property ^ (moduleScope) ]]
    [[ PropType ^ () : Type ]]

    [[ PropRule ^ (moduleScope) ]]
    [[ PropRuleBody ^ (ruleScope) ]]
    [[ PropBooleanExpr ^ (ruleScope) ]]
    [[ HasPropExpr ^ (ruleScope) ]]
    [[ VarRef ^ (ruleScope) : Type ]]
    [[ PropWhereClause ^ (ruleScope) ]]

  name resolution
    namespaces
      Module Property Variable

  relations
    anti-symmetric, anti-transitive test : Type * TypeTest

  functions
    propElemType: Type -> RefType {
      Name() -> Name(),
      Origin() -> Origin(),
      Term() -> Term(),
      Set(ty) -> ty,
      Map(ty, ty2) -> (ty, ty2)
    }

  constructors
    Prop: Type -> Type // * Type * Type -> Type
    Term : Type
    Map : Type * Type -> Type
    Set : Type -> Type
    Name : Type
    Origin : Type

    IsSingle : TypeTest
    IsDual : TypeTest

rules

// flowspec

  init ^ (global) :=
    Name() <test! IsSingle(),
    Origin() <test! IsSingle(),
    Term() <test! IsSingle(),
//    (Name(), Origin()) <test! IsSingle(),
//    (Origin(), Origin()) <test! IsSingle(),
//    (Term(), Origin()) <test! IsSingle(),

    (Name(), Origin()) <test! IsDual(),
    (Origin(), Origin()) <test! IsDual(),
    (Term(), Origin()) <test! IsDual(),
    (Name(), Name()) <test! IsDual(),
    (Origin(), Name()) <test! IsDual(),
    (Term(), Name()) <test! IsDual(),
    (Name(), Term()) <test! IsDual(),
    (Origin(), Term()) <test! IsDual(),
    (Term(), Term()) <test! IsDual(),

    new global.

  [[ FlowProgram(module, imports, defs, flowrules, proprules) ^ (global) ]] :=
    Module { module } <- global,
    moduleScope ---> global,
    Module { module } ===> moduleScope,
    Map1 [[ imports ^ (global, moduleScope) ]],
    Map1 [[ defs ^ (moduleScope) ]],
//    Map1 [[ flowrules ^ (moduleScope) ]],
//    Map1 [[ proprules ^ (moduleScope) ]],
//    distinct D(moduleScope)/Module,
//    distinct D(moduleScope)/Property,
    new moduleScope.
  
  [[ Import(mod) ^ (global, moduleScope) ]] :=
    Module { mod } -> global,
    Module { mod } |-> d,
    Module { mod } <=== moduleScope.

// Pattern

  RulePatternMap1 [[ [pattern|patterns] ^ (ruleScope) ]] :=
    RulePattern [[ pattern ^ (ruleScope) ]],
    RulePatternMap1 [[ patterns ^ (ruleScope) ]].

  RulePatternMap1 [[ [] ^ (_) ]].

  RulePattern [[ Match(_, patterns) ^ (ruleScope) ]] :=
    RulePatternMap1 [[ patterns ^ (ruleScope) ]].

  RulePattern [[ Wildcard() ^ (ruleScope) ]] := true.

  RulePattern [[ Var(x) ^ (ruleScope) ]] :=
    Variable { x } <- ruleScope.

  RulePattern [[ At(x, pattern) ^ (ruleScope) ]] :=
    Variable { x } <- ruleScope,
    RulePattern [[ pattern ^ (ruleScope) ]].

  WhereClausePatternMap1 [[ [pattern|patterns] ^ (ruleScope) ]] :=
    WhereClausePattern [[ pattern ^ (ruleScope) ]],
    WhereClausePatternMap1 [[ patterns ^ (ruleScope) ]].

  WhereClausePatternMap1 [[ [] ^ (_) ]].

  WhereClausePattern [[ Match(_, patterns) ^ (ruleScope) ]] :=
    Map1 [[ patterns ^ (ruleScope) ]].

  WhereClausePattern [[ Wildcard() ^ (ruleScope) ]] := true.

  WhereClausePattern [[ Var(x) ^ (ruleScope) ]] :=
    Variable { id } <- ruleScope.

  WhereClausePattern [[ At(x, pattern) ^ (ruleScope) ]] :=
    Variable { id } <- ruleScope,
    WhereClausePattern [[ pattern ^ (ruleScope) ]].

// Flow

// TODO: disallow pattern variable only at top-level of pattern
  [[ FlowRule(pattern, exprs) ^ (moduleScope) ]] :=
    ruleScope ---> moduleScope,
    RulePattern [[ pattern ^ (ruleScope) ]],
    Variable { Entry() } <- ruleScope,
    Variable { Exit() } <- ruleScope,
    Map1 [[ exprs ^ (ruleScope) ]],
    new ruleScope.

  [[ Recurse(x) ^ (ruleScope) ]] :=
    Variable { x } <- ruleScope.

  [[ ConditionalEdge(from, to, flowclauses) ^ (ruleScope) ]] :=
    [[ from ^ (ruleScope) ]],
    [[ to ^ (ruleScope) ]],
    Map1 [[ flowclauses ^ (ruleScope) ]].

  [[ Ref(x) ^ (ruleScope) ]] :=
    Variable { x } <- ruleScope.

  [[ e@Entry() ^ (ruleScope) ]] :=
    Variable { e } -> ruleScope.

  [[ e@Exit() ^ (ruleScope) ]] :=
    Variable { e } -> ruleScope.

  [[ HasProp(x, propname, pattern) ^ (ruleScope) ]] :=
    Variable { x } <- ruleScope,
    Property { propname } -> ruleScope,
    Property { propname } |-> dPropname,
    WhereClausePattern [[ pattern ^ (ruleScope) ]].

  [[ HasMapProp(x, propname, pattern1, pattern2) ^ (ruleScope) ]] :=
    Variable { x } <- ruleScope,
    Property { propname } -> ruleScope,
    Property { propname } |-> dPropname,
    WhereClausePattern [[ pattern1 ^ (ruleScope) ]],
    WhereClausePattern [[ pattern2 ^ (ruleScope) ]].

// Properties

  [[ Def(name, type/*, kind*/) ^ (moduleScope) ]] :=
    Property { name } <- moduleScope.
//    Property { name } : Prop(ty, kind),
//    [[ type ^ () : ty ]].

// Property rules

  [[ PropRuleWhere(pattern, body, whereclause) ^ (moduleScope) ]] :=
    ruleScope ---> moduleScope,
    RulePattern [[ pattern ^ (ruleScope) ]],
    Variable { This() } <- ruleScope,
    [[ body ^ (ruleScope) ]],
    [[ whereclause ^ (ruleScope) ]],
    new ruleScope.

  [[ PropRef(prop, ref) ^ (ruleScope) ]] :=
    Property { prop } -> ruleScope,
    Property { prop } |-> d,
    d : Prop(propty),//, kind_),
    VarRef [[ ref ^ (ruleScope) : ty1_ ]],
    elemty is propElemType of propty,
    elemty <test? IsSingle().
    // This means:
    //  ( propty == Name()
    //  ; propty == Origin()
    //  ; propty == Term()
    //  ; propty == Set(ty2_)
    //  ; propty == Map(ty3_, Origin()) ).

  [[ MapPropRef(prop, ref1, ref2) ^ (ruleScope) ]] :=
    Property { prop } -> ruleScope,
    Property { prop } |-> d,
    d : Prop(propty),//, kind_),
    elemty is propElemType of propty,
    elemty <test? IsDual(),
    VarRef [[ ref1 ^ (ruleScope) : ty1_ ]],
    VarRef [[ ref2 ^ (ruleScope) : ty2_ ]].

  VarRef [[ VarRef(id) ^ (ruleScope) : Term() ]] :=
    Variable { id } <- ruleScope.

  VarRef [[ t@This() ^ (ruleScope) : Term() ]] :=
    Variable { t } -> ruleScope,
    Variable { t } |-> d.

  [[ And(whereclause1, whereclause2) ^ (ruleScope) ]] :=
    [[ whereclause1 ^ (ruleScope) ]],
    [[ whereclause2 ^ (ruleScope) ]].

  [[ CFGArrow(pattern1, pattern2) ^ (ruleScope) ]] :=
    WhereClausePattern [[ pattern1 ^ (ruleScope) ]],
    WhereClausePattern [[ pattern2 ^ (ruleScope) ]].

  [[ HasProp(x, propname, varref) ^ (ruleScope) ]] :=
    Variable { x } <- ruleScope,
    Property { propname } -> ruleScope,
    Property { propname } |-> dPropname,
    VarRef [[ varref ^ (ruleScope) : t ]].

  [[ HasMapProp(x, propname, varref1, varref2) ^ (ruleScope) ]] :=
    Variable { x } <- ruleScope,
    Property { propname } -> ruleScope,
    Property { propname } |-> dPropname,
    VarRef [[ varref1 ^ (ruleScope) : t1 ]],
    VarRef [[ varref2 ^ (ruleScope) : t2 ]].

  [[ Not(pbe) ^ (ruleScope) ]] :=
    [[ pbe ^ (ruleScope) ]].

  [[ True() ^ (ruleScope) ]] :=
    true. // what else? :)

  // pbe : PropBooleanExpr uses a subset of constructors from PropWhereClause, so the untyped
  //  Stratego rules that this gets translated into will match them without explicit definition here
