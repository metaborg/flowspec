module flowspec/static-semantics


imports

  signatures/flowspec/-

signature
  name resolution
    namespaces
      Module Property Type Variable Constructor

  constructors
    Prop   : Type -> Type
    Term   : Type
    Map    : Type * Type -> Type
    Set    : Type -> Type
    Name   : Type
    Origin : Type
    Lub    : LatticeComponent
    Glb    : LatticeComponent
    Leq    : LatticeComponent
    Geq    : LatticeComponent
    NLeq   : LatticeComponent
    Top    : LatticeComponent
    Bottom : LatticeComponent
    Normal   : PropKind
    External : PropKind

rules

// flowspec

  init ^ (global) :=
    Type { "MaySet" } <- global,
    Type { "MustSet" } <- global,
    new global.

  [[ Module(module, imports, _, definitions) ^ (global) ]] :=
    Module { module } <- global,
    moduleScope ---> global,
    Module { module } ===> moduleScope,
    Map1 [[ imports ^ (global, moduleScope) ]],
    Map1 [[ definitions ^ (moduleScope) ]],
    distinct D(global)/Module,
    distinct D(moduleScope)/Property,
    distinct D(moduleScope)/Type,
    new moduleScope.
  
  [[ Import(mod) ^ (global, moduleScope) ]] :=
    Module { mod } -> global,
    Module { mod } |-> _,
    Module { mod } <=== moduleScope.

// Flow
rules

  [[ CFGRule(root, pattern, chains) ^ (moduleScope) ]] :=
    ruleScope ---> moduleScope,
    Pattern [[ pattern ^ (ruleScope) ]],
    [[ root ^ (ruleScope) ]],
    Variable { Start() } <- ruleScope,
    Variable { End() } <- ruleScope,
    Map1 [[ chains ^ (ruleScope) ]],
    new ruleScope.

  [[ NoRoot() ^ (ruleScope) ]] :=
    Variable { Entry() } <- ruleScope,
    Variable { Exit() } <- ruleScope.

  [[ Root() ^ (ruleScope) ]].

  // TODO: give errors on Entry() and Exit() that aren't on the start resp. end of a chain
  // TODO: give errors on Start() and End() that aren't on the start resp. end of a chain
  [[ Chain(elements) ^ (ruleScope) ]] :=
    Map1 [[ elements ^ (ruleScope) ]].

  [[ Recurse(x) ^ (ruleScope) ]] :=
    Variable { x } -> ruleScope,
    Variable { x } |-> _.

  [[ Ref(x) ^ (ruleScope) ]] :=
    Variable { x } -> ruleScope,
    Variable { x } |-> _.

  [[ e@Entry() ^ (ruleScope) ]] :=
    Variable { e } -> ruleScope,
    Variable { e } |-> _.

  [[ e@Exit() ^ (ruleScope) ]] :=
    Variable { e } -> ruleScope,
    Variable { e } |-> _.

  [[ e@Start() ^ (ruleScope) ]] :=
    Variable { e } -> ruleScope,
    Variable { e } |-> _.

  [[ e@End() ^ (ruleScope) ]] :=
    Variable { e } -> ruleScope,
    Variable { e } |-> _.

  [[ Prop(propname, x) ^ (ruleScope) ]] :=
    Variable { x } -> ruleScope,
    Variable { x } |-> _,
    Property { propname } -> ruleScope,
    Property { propname } |-> _.

// Pattern
rules

  PropPattern [[ Backward(patt, var) ^ (ruleScope) ]] :=
    Variable { var } <- ruleScope,
    Pattern [[ patt ^ (ruleScope) ]].
  PropPattern [[ Forward(var, patt) ^ (ruleScope) ]] :=
    Variable { var } <- ruleScope,
    Pattern [[ patt ^ (ruleScope) ]].

  PatternMap1 [[ [pattern|patterns] ^ (ruleScope) ]] :=
    Pattern [[ pattern ^ (ruleScope) ]],
    PatternMap1 [[ patterns ^ (ruleScope) ]].

  PatternMap1 [[ [] ^ (_) ]].

  Pattern [[ Term(_, patterns) ^ (ruleScope) ]] :=
    PatternMap1 [[ patterns ^ (ruleScope) ]].

  Pattern [[ Wildcard() ^ (ruleScope) ]] := true.

  Pattern [[ Var(x) ^ (ruleScope) ]] :=
    Variable { x } <- ruleScope.

  Pattern [[ At(x, pattern) ^ (ruleScope) ]] :=
    Variable { x } <- ruleScope,
    Pattern [[ pattern ^ (ruleScope) ]].

  Pattern [[ Int(_) ^ (_) ]]. // Literal
  Pattern [[ String(_) ^ (_) ]]. // Literal

// Properties
rules

  [[ ExtPropDef(name, type) ^ (moduleScope) ]] :=
    Property { name } <- moduleScope,
    Property { name }.kind := External(),
    [[ type ^ (moduleScope) ]].

  [[ PropDef(name, type) ^ (moduleScope) ]] :=
    Property { name } <- moduleScope,
    Property { name }.kind := Normal(),
    [[ type ^ (moduleScope) ]].

// Types
rules

  [[ TypeDef(name, vars, constrs) ^ (moduleScope) ]] :=
    Type { name } <- moduleScope,
    typeDefScope ---> moduleScope,
    Type { name } ===> typeDefScope,
    Vars [[ vars ^ (typeDefScope) ]],
    Map1 [[ constrs ^ (typeDefScope) ]],
    new typeDefScope.

  Vars [[ [v|vs] ^ (typeDefScope) ]] :=
    Type { v } -> typeDefScope,
    Type { v } |-> _,
    Vars [[ vs ^ (typeDefScope) ]].

  Vars [[ [] ^ (_) ]].

  [[ ConsDef(name, tovs) ^ (typeDefScope) ]] :=
    Constructor { name } <- typeDefScope,
    Map1 [[ tovs ^ (typeDefScope) ]].

  [[ Var(v) ^ (typeDefScope) ]] :=
    Type { v } -> typeDefScope,
    Type { v } |-> _.

  [[ LatticeDef(name, vars, latticeparts) ^ (moduleScope) ]] :=
    Type { name } <- moduleScope,
    typeDefScope ---> moduleScope,
    Type { name } ===> latticeDefScope,
    Vars [[ vars ^ (latticeDefScope) ]],
    Map1 [[ latticeparts ^ (latticeDefScope) ]],
    new latticeDefScope.

  [[ Type(type) ^ (latticeDefScope) ]] :=
    Type { name } -> latticeDefScope,
    Type { v } |-> _,
    Type { Type() } <- latticeDefScope.

  [[ Lub(var1, var2, expr) ^ (latticeDefScope) ]] :=
    Variable { Lub() } <- latticeDefScope,
    funScope ---> latticeDefScope,
    Variable { var1 } <- funScope,
    Variable { var2 } <- funScope,
    [[ expr ^ (funScope) ]],
    new funScope.

  [[ Glb(var1, var2, expr) ^ (latticeDefScope) ]] :=
    Variable { Glb() } <- latticeDefScope,
    funScope ---> latticeDefScope,
    Variable { var1 } <- funScope,
    Variable { var2 } <- funScope,
    [[ expr ^ (funScope) ]],
    new funScope.

  [[ Leq(var1, var2, expr) ^ (latticeDefScope) ]] :=
    Variable { Leq() } <- latticeDefScope,
    funScope ---> latticeDefScope,
    Variable { var1 } <- funScope,
    Variable { var2 } <- funScope,
    [[ expr ^ (funScope) ]],
    new funScope.

  [[ Geq(var1, var2, expr) ^ (latticeDefScope) ]] :=
    Variable { Geq() } <- latticeDefScope,
    funScope ---> latticeDefScope,
    Variable { var1 } <- funScope,
    Variable { var2 } <- funScope,
    [[ expr ^ (funScope) ]],
    new funScope.

  [[ NLeq(var1, var2, expr) ^ (latticeDefScope) ]] :=
    Variable { NLeq() } <- latticeDefScope,
    funScope ---> latticeDefScope,
    Variable { var1 } <- funScope,
    Variable { var2 } <- funScope,
    [[ expr ^ (funScope) ]],
    new funScope.

  [[ Top(expr) ^ (latticeDefScope) ]] :=
    Variable { Top() } <- latticeDefScope,
    [[ expr ^ (latticeDefScope) ]].

  [[ Bottom(expr) ^ (latticeDefScope) ]] :=
    Variable { Bottom() } <- latticeDefScope,
    [[ expr ^ (latticeDefScope) ]].

  [[ Name() ^ (moduleScope) ]] := true.

  [[ Term() ^ (moduleScope) ]] := true.

  [[ UserType(name, types) ^ (moduleScope) ]] :=
    Type { name } -> moduleScope,
//    Type { name } |-> dName,
    Map1 [[ types ^ (moduleScope) ]].

  [[ Tuple(type1, type2) ^ (moduleScope) ]] :=
    [[ type1 ^ (moduleScope) ]],
    [[ type2 ^ (moduleScope) ]].

  [[ Map(type1, type2) ^ (moduleScope) ]] :=
    [[ type1 ^ (moduleScope) ]],
    [[ type2 ^ (moduleScope) ]].

  [[ Set(type) ^ (moduleScope) ]] :=
    [[ type ^ (moduleScope) ]].

// Property rules
rules

  [[ PropRule(prop, pattern, expr, whereclause) ^ (moduleScope) ]] :=
    ruleScope ---> moduleScope,
    PropPattern [[ pattern ^ (ruleScope) ]],
    Property { prop } -> ruleScope,
    Property { prop } |-> propDef,
    propDef.kind := Normal() | error $[Cannot define rules of external property] @prop,
    [[ expr ^ (ruleScope) ]],
    [[ whereclause ^ (ruleScope) ]],
    new ruleScope.

  [[ NoWhereClause() ^ (ruleScope) ]] := true.
  [[ WhereClause(bindings) ^ (ruleScope) ]] :=
    Map1 [[ bindings ^ (ruleScope) ]].

  [[ Binding(var, expr) ^ (ruleScope) ]] :=
    [[ expr ^ (ruleScope) ]],
    Variable { var } <- ruleScope.

// Main
rules

  [[ FunDef(var, funpatterns, expr) ^ (moduleScope) ]] :=
    ruleScope ---> moduleScope,
    Variable { var } <- ruleScope,
    PatternMap1 [[ funpatterns ^ (ruleScope) ]],
    [[ expr ^ (ruleScope) ]],
    new ruleScope.

// Expr
rules

  [[ Term(cons, exprs) ^ (ruleScope) ]] :=
    Map1 [[ exprs ^ (ruleScope) ]].

  [[ QualRef(mod, var) ^ (ruleScope) ]] :=
    Module { mod } -> ruleScope,
    Module { mod } |-> _,
    new qualRefScope,
    Module { mod } <=== qualRefScope,
    Variable { var } -> qualRefScope,
    Variable { var } |-> _.

  [[ Ref(var) ^ (ruleScope) ]] :=
    Variable { var } -> ruleScope,
    Variable { var } |-> _.

  [[ Prop(prop, var) ^ (ruleScope) ]] :=
    Property { prop } -> ruleScope,
    Property { prop } |-> _,
    Variable { var } -> ruleScope,
    Variable { var } |-> _.

  [[ Tuple(expr, exprs) ^ (ruleScope) ]] :=
    [[ expr ^ (ruleScope) ]],
    Map1 [[ exprs ^ (ruleScope) ]].

  [[ Int(_) ^ (ruleScope) ]].
  [[ String(_) ^ (ruleScope) ]].
  
  [[ Start() ^ (ruleScope) ]].
  [[ End() ^ (ruleScope) ]].
  
  [[ Type(var) ^ (ruleScope) ]] :=
    Variable { var } -> ruleScope,
    Variable { var } |-> _.
  
  [[ Appl(ref, exprs) ^ (ruleScope) ]] :=
    [[ ref ^ (ruleScope) ]],
    Map1 [[ exprs ^ (ruleScope) ]].
  
  [[ If(c, t, e) ^ (ruleScope) ]] :=
    [[ c ^ (ruleScope) ]],
    [[ t ^ (ruleScope) ]],
    [[ e ^ (ruleScope) ]].
  
  [[ Eq(l, r) ^ (ruleScope) ]] :=
    [[ l ^ (ruleScope) ]],
    [[ r ^ (ruleScope) ]].
  
  [[ NEq(l, r) ^ (ruleScope) ]] :=
    [[ l ^ (ruleScope) ]],
    [[ r ^ (ruleScope) ]].
  
  [[ Not(e) ^ (ruleScope) ]] :=
    [[ e ^ (ruleScope) ]].
  
  [[ Match(e, arms) ^ (ruleScope) ]] :=
    [[ e ^ (ruleScope) ]],
    Map1 [[ arms ^ (ruleScope) ]].
  
  [[ MatchArm(pattern, expr) ^ (ruleScope) ]] :=
    new armScope,
    armScope ---> ruleScope,
    Pattern [[ pattern ^ (armScope) ]],
    [[ expr ^ (armScope) ]].
  
  [[ SetLiteral(exprs) ^ (ruleScope) ]] :=
    Map1 [[ exprs ^ (ruleScope) ]].
  
  [[ SetComp(expr, setcompexprs) ^ (ruleScope) ]] :=
    new setCompScope,
    setCompScope ---> ruleScope,
    [[ expr ^ (setCompScope) ]],
    Map1 [[ setcompexprs ^ (setCompScope) ]].
  
  [[ Predicate(expr) ^ (setCompScope) ]] :=
    [[ expr ^ (setCompScope) ]].
  
  [[ MatchPredicate(e, arms) ^ (setCompScope) ]] :=
    [[ e ^ (ruleScope) ]],
    Map1 [[ arms ^ (ruleScope) ]].
  
  [[ MatchArm(pattern) ^ (ruleScope) ]] :=
    Pattern [[ pattern ^ (armScope) ]].
  
  [[ Source(pattern, expr) ^ (setCompScope) ]] :=
    Pattern [[ pattern ^ (setCompScope) ]],
    [[ expr ^ (setCompScope) ]].
  
  [[ TermIndex(var) ^ (ruleScope) ]] :=
    Variable { var } -> ruleScope,
    Variable { var } |-> _.
  
  [[ NaBL2Occurrence(Occurrence(namespace, Ref(var), FSNoIndex())) ^ (ruleScope) ]] :=
    Variable { var } -> ruleScope,
    Variable { var } |-> _.
  
  [[ SetUnion(l, r) ^ (ruleScope) ]] :=
    [[ l ^ (ruleScope) ]],
    [[ r ^ (ruleScope) ]].
  
  [[ SetDifference(l, r) ^ (ruleScope) ]] :=
    [[ l ^ (ruleScope) ]],
    [[ r ^ (ruleScope) ]].
  
  [[ SetContains(l, r) ^ (ruleScope) ]] :=
    [[ l ^ (ruleScope) ]],
    [[ r ^ (ruleScope) ]].
  
  [[ SetIntersection(l, r) ^ (ruleScope) ]] :=
    [[ l ^ (ruleScope) ]],
    [[ r ^ (ruleScope) ]].
