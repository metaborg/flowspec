module flowspec/static-semantics


imports

  signatures/flowspec/-

signature
  name resolution
    namespaces
      Module Property Type Variable Constructor

  constructors
    Prop: Type -> Type
    Term : Type
    Map : Type * Type -> Type
    Set : Type -> Type
    Name : Type
    Origin : Type
    Lub    : LatticeComponent
    Glb    : LatticeComponent
    Leq    : LatticeComponent
    Geq    : LatticeComponent
    NLeq   : LatticeComponent
    Top    : LatticeComponent
    Bottom : LatticeComponent

rules

// flowspec

  init ^ (global) :=
    new global.

  [[ Module(module, imports, _, definitions) ^ (global) ]] :=
    Module { module } <- global,
    moduleScope ---> global,
    Module { module } ===> moduleScope,
    Map1 [[ imports ^ (global, moduleScope) ]],
    Map1 [[ definitions ^ (moduleScope) ]],
    distinct D(moduleScope)/Module,
    distinct D(moduleScope)/Property,
    distinct D(moduleScope)/Type,
    new moduleScope.
  
  [[ Import(mod) ^ (global, moduleScope) ]] :=
    Module { mod } -> global,
    Module { mod } |-> d,
    Module { mod } <=== moduleScope.

// Flow

  [[ CFGRule(_, pattern, chains) ^ (moduleScope) ]] :=
    ruleScope ---> moduleScope,
    Pattern [[ pattern ^ (ruleScope) ]],
    Variable { Entry() } <- ruleScope,
    Variable { Exit() } <- ruleScope,
    Variable { Start() } <- ruleScope,
    Variable { End() } <- ruleScope,
    Map1 [[ chains ^ (ruleScope) ]],
    new ruleScope.
  
  // TODO: give errors on Entry() and Exit() that aren't on the start resp. end of a chain
  // TODO: give errors on Start() and End() that aren't on the start resp. end of a chain
  [[ Chain(elements) ^ (ruleScope) ]] :=
    Map1 [[ elements ^ (ruleScope) ]].

  [[ Recurse(x) ^ (ruleScope) ]] :=
    Variable { x } <- ruleScope.

  [[ Ref(x) ^ (ruleScope) ]] :=
    Variable { x } <- ruleScope.

  [[ e@Entry() ^ (ruleScope) ]] :=
    Variable { e } -> ruleScope.

  [[ e@Exit() ^ (ruleScope) ]] :=
    Variable { e } -> ruleScope.

  [[ e@Start() ^ (ruleScope) ]] :=
    Variable { e } -> ruleScope.

  [[ e@End() ^ (ruleScope) ]] :=
    Variable { e } -> ruleScope.

  [[ Prop(propname, x) ^ (ruleScope) ]] :=
    Variable { x } -> ruleScope,
    Variable { x } |-> dX,
    Property { propname } -> ruleScope,
    Property { propname } |-> dPropname.

// Pattern

  PropPattern [[ Backward(patt, var) ^ (ruleScope) ]] :=
    Variable { var } <- ruleScope,
    Pattern [[ patt ^ (ruleScope) ]].
  PropPattern [[ Forward(var, patt) ^ (ruleScope) ]] :=
    Variable { var } <- ruleScope,
    Pattern [[ patt ^ (ruleScope) ]].
  PropPattern [[ FlowInsensitive(patt) ^ (ruleScope) ]] :=
    Pattern [[ patt ^ (ruleScope) ]].

  PatternMap1 [[ [pattern|patterns] ^ (ruleScope) ]] :=
    Pattern [[ pattern ^ (ruleScope) ]],
    PatternMap1 [[ patterns ^ (ruleScope) ]].

  PatternMap1 [[ [] ^ (_) ]].

  Pattern [[ Term(_, patterns) ^ (ruleScope) ]] :=
    PatternMap1 [[ patterns ^ (ruleScope) ]].

  Pattern [[ Wildcard() ^ (ruleScope) ]] := true.

  Pattern [[ Var(x) ^ (ruleScope) ]] :=
    Variable { x } <- ruleScope.

  Pattern [[ At(x, pattern) ^ (ruleScope) ]] :=
    Variable { x } <- ruleScope,
    Pattern [[ pattern ^ (ruleScope) ]].

  Pattern [[ Int(_) ^ (_) ]]. // Literal
  Pattern [[ String(_) ^ (_) ]]. // Literal

// Properties

  [[ PropDef(name, type) ^ (moduleScope) ]] :=
    Property { name } <- moduleScope,
    [[ type ^ (moduleScope) ]].

// Types

  [[ TypeDef(name, vars, constrs) ^ (moduleScope) ]] :=
    Type { name } <- moduleScope,
    typeDefScope ---> moduleScope,
    Type { name } ===> typeDefScope,
    Vars [[ vars ^ (typeDefScope) ]],
    Map1 [[ constrs ^ (typeDefScope) ]],
    new typeDefScope.

  Vars [[ [v|vs] ^ (typeDefScope) ]] :=
    Type { v } -> typeDefScope,
    Vars [[ vs ^ (typeDefScope) ]].

  Vars [[ [] ^ (_) ]].

  [[ ConsDef(name, tovs) ^ (typeDefScope) ]] :=
    Constructor { name } <- typeDefScope,
    Map1 [[ tovs ^ (typeDefScope) ]].

  [[ Var(v) ^ (typeDefScope) ]] :=
    Type { v } -> typeDefScope.

  [[ LatticeDef(name, vars, latticeparts) ^ (moduleScope) ]] :=
    Type { name } <- moduleScope,
    typeDefScope ---> moduleScope,
    Type { name } ===> latticeDefScope,
    Vars [[ vars ^ (latticeDefScope) ]],
    Map1 [[ latticeparts ^ (latticeDefScope) ]],
    new latticeDefScope.

  [[ Type(type) ^ (latticeDefScope) ]] :=
    Type { name } -> latticeDefScope,
    Type { Type() } <- latticeDefScope.

  [[ Lub(var1, var2, expr) ^ (latticeDefScope) ]] :=
    Variable { Lub() } <- latticeDefScope,
    funScope ---> latticeDefScope,
    Variable { var1 } <- funScope,
    Variable { var2 } <- funScope,
//    [[ expr ^ (funScope) ]],
    new funScope.

  [[ Glb(var1, var2, expr) ^ (latticeDefScope) ]] :=
    Variable { Glb() } <- latticeDefScope,
    funScope ---> latticeDefScope,
    Variable { var1 } <- funScope,
    Variable { var2 } <- funScope,
//    [[ expr ^ (funScope) ]],
    new funScope.

  [[ Leq(var1, var2, expr) ^ (latticeDefScope) ]] :=
    Variable { Leq() } <- latticeDefScope,
    funScope ---> latticeDefScope,
    Variable { var1 } <- funScope,
    Variable { var2 } <- funScope,
//    [[ expr ^ (funScope) ]],
    new funScope.

  [[ Geq(var1, var2, expr) ^ (latticeDefScope) ]] :=
    Variable { Geq() } <- latticeDefScope,
    funScope ---> latticeDefScope,
    Variable { var1 } <- funScope,
    Variable { var2 } <- funScope,
//    [[ expr ^ (funScope) ]],
    new funScope.

  [[ NLeq(var1, var2, expr) ^ (latticeDefScope) ]] :=
    Variable { NLeq() } <- latticeDefScope,
    funScope ---> latticeDefScope,
    Variable { var1 } <- funScope,
    Variable { var2 } <- funScope,
//    [[ expr ^ (funScope) ]],
    new funScope.

  [[ Top(expr) ^ (latticeDefScope) ]] :=
    Variable { Top() } <- latticeDefScope.
//    [[ expr ^ (latticeDefScope) ]].

  [[ Bottom(expr) ^ (latticeDefScope) ]] :=
    Variable { Bottom() } <- latticeDefScope.
//    [[ expr ^ (latticeDefScope) ]].

  [[ Name() ^ (moduleScope) ]] := true.

  [[ Term() ^ (moduleScope) ]] := true.

  [[ UserType(name, types) ^ (moduleScope) ]] :=
    Type { name } -> moduleScope,
    Type { name } |-> dName,
    Map1 [[ types ^ (moduleScope) ]].

  [[ Tuple(type1, type2) ^ (moduleScope) ]] :=
    [[ type1 ^ (moduleScope) ]],
    [[ type2 ^ (moduleScope) ]].

  [[ Map(type1, type2) ^ (moduleScope) ]] :=
    [[ type1 ^ (moduleScope) ]],
    [[ type2 ^ (moduleScope) ]].

  [[ Set(type) ^ (moduleScope) ]] :=
    [[ type ^ (moduleScope) ]].

// Property rules

  [[ PropRule(prop, pattern, expr, whereclause) ^ (moduleScope) ]] :=
    ruleScope ---> moduleScope,
    PropPattern [[ pattern ^ (ruleScope) ]],
    Property { prop } -> ruleScope,
//    [[ expr ^ (ruleScope) ]],
    [[ whereclause ^ (ruleScope) ]],
    new ruleScope.

  [[ NoWhereClause() ^ (ruleScope) ]] := true.
  [[ WhereClause(bindings) ^ (ruleScope) ]] :=
    Map1 [[ bindings ^ (ruleScope) ]].

  [[ Binding(var, expr) ^ (ruleScope) ]] :=
//    [[ expr ^ (ruleScope) ]],
    Variable { var } <- ruleScope.

// Main

  [[ FunDef(var, funpatterns, expr) ^ (moduleScope) ]] :=
    ruleScope ---> moduleScope,
    Variable { var } <- ruleScope,
    PatternMap1 [[ funpatterns ^ (ruleScope) ]],
//    [[ expr ^ (ruleScope) ]],
    new ruleScope.

// Expr
// TODO, update these:

  [[ Term(cons, exprs) ^ (ruleScope) ]] :=
    Map1 [[ exprs ^ (ruleScope) ]].

  [[ Ref(v) ^ (ruleScope) ]] :=
    Variable { v } -> ruleScope.

  [[ Tuple(expr, exprs) ^ (ruleScope) ]] :=
    [[ expr ^ (ruleScope) ]],
    Map1 [[ exprs ^ (ruleScope) ]].
