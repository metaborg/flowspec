module generate-stratego

imports

signatures/flowspec/-
libspoofax/stratego/debug
flowspec/desugar
flowspec/utils
flowspec/prop-direction
flowspec/dependencies
nabl2/shared/-

rules

// flowspec
// flowspec - Module
gen-str: Module(modulename, import*, def*) ->
  ${module {modulename}

  imports

  signatures/flowspec/-
  flowspec/shared
  nabl2/shared/-

  signatures/-
  {importstring}

  rules // Dependencies between properties

  flowspec--provide-prop-deps =
    ![ {depstring} ]

  rules // Directions of properties

  flowspec--provide-prop-dirs =
    ![ {dirstring} ]

  rules // Types of properties

  flowspec--provide-prop-types =
    ![ {propstring} ]

  rules // Transfer functions of properties

  {transferstring}

  rules // CFG rules

  {cfgstring}
}
with
  importstring := <map(?Import(<id>));lines_> import*
; cfgstring := <retain-all(?CFGRule(_, _));map(gen-str);lines_> def*
; dependencies := <prop-dependency-graph> def*
; depstring := <map(\(l,r) -> ${("{l}", "{r}")}\);csv-lines> dependencies
; directions := <prop-direction> def*
; dirstring := <map(\(n,d) -> ${("{n}", {<gen-str> d})}\);csv-lines> directions
; propstring := <retain-all(?PropDef(_,_));map(gen-str);csv-lines> def*
; transferstring := <retain-all(?PropRule(_, _, _, _, _));map(gen-str);lines_> def*
// TODO: custom type / lattice definitions

gen-str: Fw() -> "Fw()"
gen-str: Bw() -> "Bw()"
gen-str: NA() -> "NA()"

gen-str: PropDef(propname,type) -> ${("{propname}", {<gen-ast-str> type})}

// Flow - CFGRule

gen-str: CFGRule(pattern, chain*) ->
${flowspec--generate-cfg-rule:
    this@{patternstring} ->
      [ {pairstring} ]
  with
    index := <nabl2--get-ast-index> this
  {<lines_> [indicesstr*, recursesstr*]}
}
with
  patternstring := <gen-match-pattern> pattern
  // handle recursive calls
; recurses := <mapconcat(\Chain(l) -> <retain-all(?Recurse(_))> l\);strip-annos;nub> chain*
; recursesstr* := <map(gen-recurse-str)> recurses
  // use recursive call result pairs
; pairstring1* := <map(\Recurse(v) -> ${recurse-{v}*}\)> recurses
  // generate pairs from chains
; pairs := <mapconcat(\Chain(l) -> <zip> (<init> l, <Tl> l)\)> chain*
  // build normal pairs from the chains
; pairstring2* :=
    <map(\(el1, el2) -> ${({<gen-cfg-l-str> el1}, {<gen-cfg-r-str> el2})}\)> pairs
; pairstring := <csv-lines> [ pairstring1*, pairstring2* ]
  // build indices
; indices := <pattern-variables> pattern
; indicesstr* := <map(gen-index-str)> indices

gen-recurse-str: Recurse(v) ->
  ${; recurse-{v}* := <flowspec--generate-cfg> match-{v}
    ; entry-{v} := Entry(index-{v})
    ; exit-{v} := Exit(index-{v})}

gen-index-str: v -> ${; index-{v} := <nabl2--get-ast-index> match-{v}}

gen-cfg-l-str: Recurse(v) -> ${exit-{v}}
gen-cfg-l-str: Entry() -> ${Entry(index)}
gen-cfg-l-str = gen-cfg-str
gen-cfg-r-str: Recurse(v) -> ${entry-{v}}
gen-cfg-r-str: Exit() -> ${Exit(index)}
gen-cfg-r-str = gen-cfg-str
gen-cfg-str: Label(v) -> ${index-{v}}
gen-cfg-str: Prop(p, v) -> <with(fail|"Sorry, stubbing out prop support in CFG for now")>

// Property - PropRule

gen-str: PropRule(propname, pattern, rhs, for, whereclause) ->
${flowspec--generate-transfer-rule:
  this@{patternstring} ->
    ("{propname}", index, pattern, rhs, for, whereclause)
  with
    index := <nabl2--get-ast-index> this
  {<lines_> indicesstr}
  ; rhs := {rhsstring}
  ; for := {forstring}
  ; whereclause := {whereclausestring}
  ; pattern := {patternaststring}
}
with
  patternstring := <gen-match-pattern> pattern
; this := <pattern-this;strip-annos> pattern
; rhsstring := <gen-ast-str> rhs
; forstring := <gen-ast-str> for
; whereclausestring := <gen-ast-str> whereclause
; patternaststring := <gen-ast-str> pattern
; indicesstr := <pattern-variables;map(gen-index-str)> pattern

gen-ast-str: Term(consname, exprs) -> ${Term("{consname}", [{<map(gen-ast-str);csv> exprs}])}
gen-ast-str: QualRef(modname, var) -> ${QualRef("{modname}", "{var}")}
gen-ast-str: Ref(var) -> ${Ref("{var}")}
gen-ast-str: PropRef(propname) -> ${PropRef("{propname}")}
gen-ast-str: Tuple(expr, exprs) -> ${Tuple({<gen-ast-str> expr}, [{<map(gen-ast-str);csv> exprs}])}
gen-ast-str: Int(i) -> ${Int("{i}")}
gen-ast-str: String(s) -> ${String("{s}")}
gen-ast-str: Label(v) -> ${Label("{v}")}
gen-ast-str: Type(var) -> ${Type("{var}")}
gen-ast-str: Abs(pattern, expr) -> ${Abs({<gen-ast-str> pattern}, {<gen-ast-str> expr})}
gen-ast-str: Appl(fun, arg) -> ${Appl({<gen-ast-str> fun}, {<gen-ast-str> arg})}
gen-ast-str: If(cond, then, else) ->
  ${If({<gen-ast-str> cond}, {<gen-ast-str> then}, {<gen-ast-str> else})}
gen-ast-str: Eq(a, b) -> ${Eq({<gen-ast-str> a}, {<gen-ast-str> b})}
gen-ast-str: NEq(a, b) -> ${NEq({<gen-ast-str> a}, {<gen-ast-str> b})}
gen-ast-str: Match(subj, arms) -> ${Match({<gen-ast-str> subj}, [{<map(gen-ast-str);csv> arms}])}

gen-ast-str: MatchArm(pattern, expr) -> ${MatchArm({<gen-ast-str> pattern}, {<gen-ast-str> expr})}

gen-ast-str: ADTAppl(appl, patt) -> ${ADTAppl({<gen-ast-str> appl}, {<gen-ast-str> patt})}
gen-ast-str: ADTCons(consname) -> ${ADTCons("{consname}")}
// We already covered Term
gen-ast-str: Wildcard() -> ${Wildcard()}
gen-ast-str: Var(var) -> ${Var("{var}")}
gen-ast-str: At(var, patt) -> ${At("{var}", {<gen-ast-str> patt})}
// We already covered Tuple

gen-ast-str: NoWhereClause() -> ${[]}
gen-ast-str: WhereClause(bindings) -> ${[{<map(gen-ast-str);csv> bindings}]}
gen-ast-str: Binding(var, expr) -> ${Binding("{var}", {<gen-ast-str> expr})}

gen-ast-str: Entry() -> ${Entry()}
gen-ast-str: Exit() -> ${Exit()}
gen-ast-str: Recurse(v) -> <with(fail|"Uhm, recursive call in a for clause?")>
gen-ast-str: Prop(propname, var) -> ${Prop("{propname}", "{var}")}
// We already covered Label

gen-ast-str: Name() -> ${Name()}
gen-ast-str: Term() -> ${Term()}
gen-ast-str: UserType(name, args) -> ${UserType("{name}", [{<map(gen-ast-str);csv> args}])}
gen-ast-str: Tuple(ltype, rtype) -> ${Tuple({<gen-ast-str> ltype}, {<gen-ast-str> rtype})}
gen-ast-str: Map(ktype, vtype) -> ${Map({<gen-ast-str> ktype}, {<gen-ast-str> vtype})}
gen-ast-str: Set(type) -> ${Set({<gen-ast-str> type})}

// Pattern - Pattern, Wildcard
gen-match-pattern: Var(ident) -> $[match-[ident]]
gen-match-pattern: At(ident, pattern) -> $[match-[ident]@[patternstring]]
with patternstring := <gen-match-pattern> pattern
gen-match-pattern: Term(consname, subpattern*) -> $[[consname]([subpatternsstring])]
with subpatternsstring := <map(gen-match-pattern);csv> subpattern*
gen-match-pattern: Wildcard() -> "_"

//gen-constraint-pattern: Var(ident) -> $[index-[ident]]
//gen-constraint-pattern: At(ident, pattern) -> $[index-[ident]@[patternstring]]
//with patternstring := <gen-constraint-pattern> pattern
//gen-constraint-pattern: Term(consname, subpattern*) -> $[[consname]([subpatternsstring])]
//with subpatternsstring := <map(gen-constraint-pattern);csv> subpattern*
//gen-constraint-pattern: Wildcard() -> "_"

pattern-variables: Var(ident) -> [ident]
pattern-variables: At(ident, pattern) -> [ ident | <pattern-variables> pattern ]
pattern-variables: Term(_, subpattern*) -> <mapconcat(pattern-variables)> subpattern*
pattern-variables: Wildcard() -> []

//constraint-variables = pattern-variables
//constraint-variables: Ref(ident) -> [ident]
//constraint-variables: And(l, r) -> <mapconcat(constraint-variables)> [ l, r ]
//constraint-variables: ASTRelation(p, c) -> <mapconcat(constraint-variables)> [ p, c ]
//constraint-variables: CFGArrow(f, t) -> <mapconcat(constraint-variables)> [ f, t ]
//constraint-variables: Filter(b) -> <constraint-variables> b
//constraint-variables: True() -> []
//constraint-variables: HasProp(l, _, p) -> [ l | <constraint-variables> p ]
//constraint-variables: HasPropContrib(l, _, p) -> [ l | <constraint-variables> p ]
//constraint-variables: Mapping(l, r) -> <mapconcat(constraint-variables)> [ l, r ]
