module generate-stratego

imports

signatures/flowspec/-

libspoofax/stratego/debug
libspoofax/core/language

flowspec/desugar
flowspec/utils
flowspec/dependencies

nabl2/shared/-

signature
  constructors
    Split : Term -> Term
    Merge : Term -> Term

rules

// Module
gen-str: Module(modulename, import*, astroot*, def*) ->
  ${module {modulename}

  imports
    signatures/nabl2/shared/-
    signatures/nabl2/shared/common/-
    signatures/nabl2/shared/constraints/-
    nabl2/shared/-
    signatures/nabl2/runtime/-
    signatures/nabl2/runtime/analysis/-
    signatures/nabl2/runtime/common/-
    signatures/nabl2/runtime/constraints/-
    nabl2/runtime/-
    nabl2/runtime/analysis/-
    nabl2/runtime/prelude/-
    nabl2/runtime/stdlib/-

  imports
    {importstring}

  rules
  
  {cfgstring}
  
  flowspec--proprule(|index): term ->
    [
      {matchpropsstring}
    ]
  
  {propstring}
}
with
  importstring := <map(?Import(<id>));lines_> import*
; astroot' := <map(\AstRoot(cons, children) -> (<strip-annos> cons, <length> children)\)> astroot*
; cfgstring := <retain-all(?CFGRule(_, _, _));map(gen-str(|astroot'));lines_> def*
; proprule* := <retain-all(?PropRule(_, _, _, _))> def*
; propnames := <retain-all(?PropDef(<id>, _)); strip-annos> def*
; matchpropsstring := <map(\n -> ${<flowspec--proprule-{n}(|index)> term}\);csv-lines> propnames
; propstring := <number-prop-rules(|propnames);map(gen-str);lines_> proprule*

number-prop-rules(|propnames): proprules -> numberedproprules
with
  named := <map(\p@PropRule(n,_,_,_) -> (<strip-annos> n,p)\)> proprules
; numberedproprules := <thread-map(number-prop-rules-helper);Fst> (named, <map(!(<id>, 0))> propnames)

number-prop-rules-helper: ((n,p),l) -> ((n',p),l')
with
  n' := <lookup> (n,l)
; l' := [(n,<inc> n') | l]

// Flow - CFGRule

gen-str(|astroot*): CFGRule(r, pattern, chain*) ->
${nabl2--generate-constraint-{rulename}-rule(|):
    _ -> <\[] -> CTrue(<nabl2--get-ast-index> nabl2_term)\ <+ foldr1(?[<id>], !CConj(<Fst>, <Snd>))> nabl2_constraint
    with(?(nabl2_source, nabl2_term, nabl2_args))
    where({patternstr} := nabl2_term)
    with({paramcons}(
           nabl2_params@({paramstr})
         ) := nabl2_args
         <+ fatal-err(
            | <concat-strings> [ "Cannot match expected "
                               , "^ ({paramstr})"
                               , " with actual "
                               , <nabl2--pp-flat-args> nabl2_args
                               , " when matching "
                               , "{patternstr}"
                               , " with "
                               , <pp-NaBL2-Term> nabl2_term
                               , "."
                               ]
            ))
    with(if nabl2--is-debug-collection-enabled then
           nabl2--collection-info-msg(
           | <concat-strings> [ "{rulename}"
                              , " [[ "
                              , <pp-NaBL2-Term> nabl2_term
                              , " ^ "
                              , <pp-NaBL2-CTerm> nabl2_params
                              , " ]]"
                              ]
           )
         end)
    with({<?[] < !"id" + semi-lines> recursevarsstr*})
    with(nabl2_index := <nabl2--get-ast-index> nabl2_term
         ; nabl2_metadata := [CAstProperty(nabl2_index, CFGParams(), nabl2_params)])
    with({<?[] < !"id" + semi-lines> [refvarsstr*, rootvarstr*, mergedrhsvarstr*, mergedlhsvarstr*]})
    with(refsstr* :=
           <concat>
             [ {<csv-lines> refsstr*}
             ])
    with(nabl2_constraint := <conc ; nabl2--flatten-list>
      ( nabl2_metadata
      , [ {<csv-lines> [rootstr*, pairstr*, mergedrhsstr*, mergedlhsstr*, "refsstr*", recursesstr*]}
        ]
      ))
}
with
  if <match-ast-root-str(|astroot*)> pattern
    then rulename := "default-cfg"
       ; rootvarstr* := <map(gen-new-synthetic-cfg-node-str)> ["t_start", "t_end"]//<conc> ( , <map(gen-new-var-str)> ["entry", "exit"])
       ; rootstr* := [] //<map(gen-directed-edge-str)> [("exit", "t_end"), ("t_start", "entry")]
       ; paramstr := "_"
       ; paramcons := "Params"
    else rulename := "cfg"
       ; if <?Root()> r
           then rootstr* := [<gen-directed-edge-str> ("exit", "t_end"), <gen-equal-str> ("t_start", "entry")]
              ; rootvarstr* := <map(gen-new-synthetic-cfg-node-str)> ["t_start", "t_end"]
              ; paramstr := "entry, exit, _, _"
              ; paramcons := "CFGParams"
           else rootstr* := []
              ; rootvarstr* := []
              ; paramstr := "entry, exit, t_start, t_end"
              ; paramcons := "CFGParams"
         end
  end
; chain'* := <strip-annos> chain*
; patternstr := <gen-match-pattern-str> pattern
  // handle recursive calls
; recurses := <mapconcat(?Chain(<retain-all(?Recurse(_))>));nub> chain'*
; recursevarsstr* := <map(gen-recurse-var-str)> recurses
; recursesstr* := <map(gen-recurse-str)> recurses
  // handle new nodes
; refs := <mapconcat(?Chain(<retain-all(?Ref(_))>));nub> chain'*
; refvarsstr* := <map(gen-ref-var-str)> refs
; refsstr* := <map(gen-ref-str)> refs
  // generate pairs from chains
; pairs := <mapconcat(\Chain(l) -> <zip> (<init> l, <Tl> l)\)> chain'*

; lhses := <map(Fst);nub> pairs
; rhsesmerged := <map(\lhs -> (lhs, <retain-all(?(lhs, <id>))> pairs)\)> lhses
; (mergedrhsvarstr*, mergedrhsstr*) := <retain-all(gen-rhs-merged-str);unzip> rhsesmerged
; pairs2 := <mapconcat(use-merged-rhs-str)> rhsesmerged

; rhses := <map(Snd);nub> pairs2
; lhsesmerged := <map(\rhs -> (<retain-all(?(<id>, rhs))> pairs2, rhs)\)> rhses
; (mergedlhsvarstr*, mergedlhsstr*) := <retain-all(gen-lhs-merged-str);unzip> lhsesmerged
; pairs3 := <mapconcat(use-merged-lhs-str)> lhsesmerged
  // build normal pairs from the chains
; pairstr* := <map(gen-pair-to-edge-str)> pairs3

match-ast-root-str(|astroot*): Term(cons, children) -> <id>
where
  cons' := <strip-annos> cons
; count := <length> children
; <getfirst(?(cons', count))> astroot*

match-ast-root-str(|astroot*): At(_, pattern) -> <match-ast-root-str(|astroot*)> pattern

gen-new-cfg-node-str: (termname, nodename) ->
  ${{nodename} := <nabl2--new-cfg-node(|nabl2_source)
                   ;try(nabl2--copy-origin(|nabl2_term))
                   ;nabl2-copy-ast-index(|{termname})> "{nodename}"}

gen-new-synthetic-cfg-node-str: nodename ->
  ${{nodename} := <nabl2--new-cfg-node(|nabl2_source)
                   ;try(nabl2--copy-origin(|nabl2_term))> "{nodename}"}

gen-new-var-str: v ->
  ${{v} := <nabl2--fresh-var(|nabl2_source)
            ;try(nabl2--copy-origin(|nabl2_term))> "{v}"}

gen-directed-edge-str: (lhs, rhs) ->
  ${CFDirectEdge(
      {lhs}
    , {rhs}
    , <nabl2--get-ast-index> nabl2_term
    )}

gen-equal-str: (lhs, rhs) ->
  ${CEqual(
      {lhs}
    , {rhs}
    , Message(Error(), Default(), <nabl2--get-ast-index> nabl2_term)
    )}

gen-recurse-var-str: Recurse(v) ->
  <map(gen-new-var-str);semi-lines> [${entry{v}}, ${exit{v}}]

gen-recurse-str: Recurse(v) ->
  ${<nabl2--generate-constraint(nabl2--generate-constraint-{rulename}-rule|"{rulename}")>
      ( nabl2_source
      , match{v}
      , CFGParams((entry{v}, exit{v}, t_start, t_end))
      )}
with rulename := "cfg"

gen-ref-var-str: Ref(v) ->
  <gen-new-cfg-node-str> (${match{v}}, ${node{v}})

gen-ref-str: Ref(v) ->
  ${<flowspec--proprule(|<nabl2--get-ast-index> match{v})> match{v}}

gen-rhs-merged-str: (Entry(), rhses@[_,_|_]) -> (<gen-new-synthetic-cfg-node-str> "entrysplit", <gen-equal-str> ("entry", "entrysplit"))
gen-rhs-merged-str: (Start(), rhses@[_,_|_]) -> (<gen-new-synthetic-cfg-node-str> "startsplit", <gen-directed-edge-str> ("t_start", "startsplit"))
gen-rhs-merged-str: (Ref(v), rhses@[_,_|_]) -> (<gen-new-synthetic-cfg-node-str> ${node{v}split}, <gen-directed-edge-str> (${node{v}}, ${node{v}split}))
gen-rhs-merged-str: (Recurse(v), rhses@[_,_|_]) -> (<gen-new-synthetic-cfg-node-str> ${split{v}}, <gen-equal-str> (${exit{v}}, ${split{v}}))

use-merged-rhs-str = (id, ?[<id>]);MkSingleton
use-merged-rhs-str: (Entry(), rhses@[_,_|_]) -> <map(!(Split("entrysplit"), <id>))> rhses
use-merged-rhs-str: (Start(), rhses@[_,_|_]) -> <map(!(Split("startsplit"), <id>))> rhses
use-merged-rhs-str: (Ref(v), rhses@[_,_|_]) -> <map(!(Split(${node{v}split}), <id>))> rhses
use-merged-rhs-str: (Recurse(v), rhses@[_,_|_]) -> <map(!(Split(${split{v}}), <id>))> rhses

gen-pair-to-edge-str: (Entry(), rhs) -> <gen-equal-str> ("entry", <gen-cfg-rhs-str> rhs)
gen-pair-to-edge-str: (Start(), rhs) -> <gen-directed-edge-str> ("t_start", <gen-cfg-rhs-str> rhs)
gen-pair-to-edge-str: (Ref(v), rhs) -> <gen-directed-edge-str> (${node{v}}, <gen-cfg-rhs-str> rhs)
gen-pair-to-edge-str: (Recurse(v), rhs) -> <gen-equal-str> (${exit{v}}, <gen-cfg-rhs-str> rhs)
gen-pair-to-edge-str: (Split(lhs), rhs) -> <gen-directed-edge-str> (lhs, <gen-cfg-rhs-str> rhs)
gen-pair-to-edge-str: (Prop(_, _), _) -> <with(fail|"Sorry, stubbing out prop support in CFG for now")>
gen-pair-to-edge-str: (Exit(), _) -> <with(fail|"Error: exit on lhs of arrow")>
gen-pair-to-edge-str: (End(), _) -> <with(fail|"Error: end on lhs of arrow")>

gen-lhs-merged-str: (lhses@[_,_|_], r@Exit()) -> (<gen-new-synthetic-cfg-node-str> "exitmerge", <gen-directed-edge-str> ("exitmerge", <gen-cfg-rhs-str> r))
gen-lhs-merged-str: (lhses@[_,_|_], r@End()) -> (<gen-new-synthetic-cfg-node-str> "endmerge", <gen-directed-edge-str> ("endmerge", <gen-cfg-rhs-str> r))
gen-lhs-merged-str: (lhses@[_,_|_], r@Ref(v)) -> (<gen-new-synthetic-cfg-node-str> ${node{v}merge}, <gen-directed-edge-str> (${node{v}merge}, <gen-cfg-rhs-str> r))
gen-lhs-merged-str: (lhses@[_,_|_], r@Recurse(v)) -> (<gen-new-synthetic-cfg-node-str> ${merge{v}}, <gen-directed-edge-str> (${merge{v}}, <gen-cfg-rhs-str> r))

use-merged-lhs-str = (?[<id>], id);MkSingleton
use-merged-lhs-str: (lhses@[_,_|_], Exit()) ->  <map(!(<id>, Merge("exitmerge")))> lhses
use-merged-lhs-str: (lhses@[_,_|_], End()) -> <map(!(<id>, Merge("endmerge")))> lhses
use-merged-lhs-str: (lhses@[_,_|_], Ref(v)) -> <map(!(<id>, Merge(${node{v}merge})))> lhses
use-merged-lhs-str: (lhses@[_,_|_], Recurse(v)) -> <map(!(<id>, Merge(${merge{v}})))> lhses

gen-cfg-rhs-str: Merge(v) -> v
gen-cfg-rhs-str: Recurse(v) -> ${entry{v}}
gen-cfg-rhs-str: Exit() -> ${exit}
gen-cfg-rhs-str: End() -> ${t_end}
gen-cfg-rhs-str: Ref(v) -> ${node{v}}
gen-cfg-rhs-str: Prop(p, v) -> <with(fail|"Sorry, stubbing out prop support in CFG for now")>
gen-cfg-rhs-str: Entry() -> <with(fail|"Error: entry on rhs of arrow")>
gen-cfg-rhs-str: Start() -> <with(fail|"Error: start on rhs of arrow")>

// Pattern - Pattern, Wildcard
gen-match-pattern-str: Var(ident) -> $[match[ident]]
gen-match-pattern-str: At(ident, pattern) -> $[match[ident]@[patternstring]]
with patternstring := <gen-match-pattern-str> pattern
gen-match-pattern-str: Term(consname, subpattern*) -> $[[consname]([subpatternsstring])]
with subpatternsstring := <map(gen-match-pattern-str);csv> subpattern*
gen-match-pattern-str: Wildcard() -> "_"

pattern-vars(|prefix): Var(ident) -> [$[[prefix][ident]]]
pattern-vars(|prefix): At(ident, pattern) -> [$[[prefix][ident]] | <pattern-vars(|prefix)> pattern]
pattern-vars(|prefix): Term(consname, subpattern*) -> <mapconcat(pattern-vars(|prefix))> subpattern*
pattern-vars(|prefix): Wildcard() -> []

pattern-in-dir: Forward(_, p) -> p
pattern-in-dir: Backward(p,_) -> p
pattern-in-dir: FlowInsensitive(p) -> p

// PropRule

gen-str: (n, PropRule(name, pattern, _, _)) -> rulestring
with
  pattern' := <pattern-in-dir> pattern
; patternstring := <gen-match-pattern-str> pattern'
; vars := <pattern-vars(|"match")> pattern'
; rulestring := ${flowspec--proprule-{name}(|index): {patternstring} -> CAstProperty(index, TF("{name}"), ({n}, [{<csv> vars}]))}
