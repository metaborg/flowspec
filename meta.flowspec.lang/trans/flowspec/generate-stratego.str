module generate-stratego

imports

signatures/flowspec/-

libspoofax/stratego/debug
libspoofax/core/language

flowspec/desugar
flowspec/utils
flowspec/dependencies

nabl2/shared/-
nabl2/api

signature
  constructors
    Split : Term -> Term
    Merge : Term -> Term

rules

// Module
gen-str: Module(modulename, import*, _, def*) ->
${module flowspec/{modulename}

imports
  signatures/nabl2/shared/-
  signatures/nabl2/shared/common/-
  signatures/nabl2/shared/constraints/-
  nabl2/shared/-
  signatures/nabl2/runtime/-
  signatures/nabl2/runtime/analysis/-
  signatures/nabl2/runtime/common/-
  signatures/nabl2/runtime/constraints/-
  nabl2/runtime/-
  nabl2/runtime/analysis/-
  nabl2/runtime/prelude/-
  nabl2/runtime/stdlib/-
  nabl2/api
  
  flowspec/api
  signatures/flowspec/runtime/-

imports
  {importstring}

rules

nabl2--generate-constraint-default-cfg-rule:
  _ -> <flowspec--constraint-list-to-cconj(<nabl2--get-ast-index> fs_term)> result
with(?(nabl2_source, fs_term, Params(_)))
with(result := <collect-om(flowspec--generate-cfg-root-constraint(|nabl2_source), conc)> fs_term)

{cfgstring}

flowspec--proprule(|index):
  term -> {matchpropsstring}

flowspec--prop-names =
  ![ {propnamesstring}
   ]

{propstring}
}
with
  a := <nabl2-get-ast-analysis>
; importstring := <map(?Import(<!("flowspec/", <id>);conc-strings>) + ?ExtImport(<id>));lines_> import*
; cfgstring := <retain-all(?CFGRule(_, _, _));map(gen-str);lines_> def*
; proprule* := <retain-all(?PropRule(_, _, _, _))> def*
; propnames := <retain-all(?PropDef(<id>, _))> def*
; matchpropsstring := <map(\n -> ${<flowspec--proprule-{n}(|index)> term}\);constraint-str-list-to-cconj> propnames
; propstring := <number-prop-rules(|a, <map(nabl2-mk-occurrence(|"Property"))> propnames);gen-prop-str(|propnames);lines_> proprule*
; propnamesstring := <map(!${"{<id>}"});csv-lines> propnames

number-prop-rules(|a, propnames): proprules -> numberedproprules
with
  named := <map(\p@PropRule(n,_,_,_) -> (<nabl2-mk-occurrence(|"Property"); nabl2-get-resolved-name(|a); Fst> n,p)\)> proprules
; numberedproprules := <thread-map(number-prop-rules-helper);Fst> (named, <map(!(<id>, 0))> propnames)

number-prop-rules-helper: ((n,p),l) -> ((n',p),l')
with
  n' := <lookup> (n,l)
; l' := [(n,<inc> n') | l]

// Flow - CFGRule

gen-str: CFGRule(r, pattern, chain*) ->
${{ruleheader}
  with({<semi-lines> [indexdefstr, vardefstr*]})
  with(fs_constraint := {constraintstr})
}
with
  patternstr := <gen-match-pattern-str> pattern
; ruleheader := <cfg-root-rule-header(|patternstr)> r
; rrconstr* := <cfg-root-related-constraintstr> r
; rrvarstr* := <cfg-root-related-varstr> r
; chain'* := <strip-annos> chain*
  // handle recursive calls
; recurses := <mapconcat(?Chain(<retain-all(?Recurse(_))>));nub> chain'*
; recursevarsstr* := <map(gen-recurse-var-str)> recurses
; recursesstr* := <map(gen-recurse-str)> recurses
  // handle new nodes
; refs := <mapconcat(?Chain(<retain-all(?Ref(_))>));nub> chain'*
; refvarsstr* := <map(gen-ref-var-str)> refs
; refsstr* := <map(gen-ref-str)> refs
  // generate pairs from chains
; pairs := <mapconcat(\Chain(l) -> <zip> (<init> l, <Tl> l)\)> chain'*

; lhses := <map(Fst);nub> pairs
; rhsesmerged := <map(\lhs -> (lhs, <retain-all(?(lhs, <id>))> pairs)\)> lhses
; (mergedrhsvarstr*, mergedrhsstr*) := <retain-all(gen-rhs-merged-str);unzip> rhsesmerged
; pairs2 := <mapconcat(use-merged-rhs-str)> rhsesmerged

; rhses := <map(Snd);nub> pairs2
; lhsesmerged := <map(\rhs -> (<retain-all(?(<id>, rhs))> pairs2, rhs)\)> rhses
; (mergedlhsvarstr*, mergedlhsstr*) := <retain-all(gen-lhs-merged-str);unzip> lhsesmerged
; pairs3 := <mapconcat(use-merged-lhs-str)> lhsesmerged
  // build normal pairs from the chains
; pairstr* := <map(gen-pair-to-edge-str)> pairs3

; indexdefstr := "fs_index := <nabl2--get-ast-index> fs_term"
; vardefstr* := [recursevarsstr*, refvarsstr*, rrvarstr*, mergedrhsvarstr*, mergedlhsvarstr*]
; constraintstr* := [rrconstr*, pairstr*, mergedrhsstr*, mergedlhsstr*, refsstr*, recursesstr*]
; constraintstr := <constraint-str-list-to-cconj> constraintstr*

cfg-root-rule-header(|patternstr): Root() ->
${flowspec--generate-cfg-root-constraint(|nabl2_source):
    fs_term@{patternstr} -> fs_constraint}

cfg-root-rule-header(|patternstr): NoRoot() ->
${flowspec--generate-cfg-constraint: _ -> fs_constraint
  with(?(nabl2_source, fs_term, CFGParams(fs_params@(entry, exit, t_start, t_end))))
  where({patternstr} := fs_term)}

cfg-root-related-varstr: Root() -> [<gen-cfg-start-node-str> "t_start", <gen-cfg-end-node-str> "t_end"]
cfg-root-related-varstr: NoRoot() -> []

cfg-root-related-constraintstr: Root() -> []
cfg-root-related-constraintstr: NoRoot() -> ["CAstProperty(fs_index, CFGParams(), fs_params)"]

gen-cfg-node-str: v -> <gen-cfg-node-str(|"Normal")> (${<nabl2-get-ast-index> match{v}}, ${node{v}})
gen-cfg-start-node-str: nodename -> <gen-cfg-node-str(|"Start")> ("fs_index", nodename)
gen-cfg-end-node-str: nodename -> <gen-cfg-node-str(|"End")> ("fs_index", nodename)
gen-artificial-cfg-node-str: nodename -> <gen-cfg-node-str(|"Artificial")> ("fs_index", nodename)

gen-cfg-node-str(|kind): (termname, nodename) ->
  ${{nodename} := <flowspec--cfg-node(|{termname},{kind}());try(nabl2--copy-origin(|{termname}))> "{nodename}"}

gen-new-var-str: v ->
  ${{v} := <nabl2--fresh-var(|nabl2_source);try(nabl2--copy-origin(|fs_term))> "{v}"}

gen-directed-edge-str: (lhs, rhs) ->
  ${CFDirectEdge({lhs}, {rhs}, fs_index)}

gen-equal-str: (lhs, rhs) ->
  ${CEqual({lhs}, {rhs}, Message(Error(), Default(), fs_index))}

gen-recurse-var-str: Recurse(v) ->
  <map(gen-new-var-str);semi-lines> [${entry{v}}, ${exit{v}}]

gen-recurse-str: Recurse(v) ->
  ${<nabl2--generate-constraint(flowspec--generate-cfg-constraint|"{rulename}")> ( nabl2_source, match{v}, CFGParams((entry{v}, exit{v}, t_start, t_end)) )}
with rulename := "cfg"

gen-ref-var-str: Ref(v) -> <gen-cfg-node-str> v

gen-ref-str: Ref(v) ->
  ${<flowspec--proprule(|<nabl2--get-ast-index> match{v})> match{v}}

gen-rhs-merged-str: (Entry(), rhses@[_,_|_]) -> (<gen-artificial-cfg-node-str> "entrysplit", <gen-equal-str> ("entry", "entrysplit"))
gen-rhs-merged-str: (Start(), rhses@[_,_|_]) -> (<gen-artificial-cfg-node-str> "startsplit", <gen-directed-edge-str> ("t_start", "startsplit"))
gen-rhs-merged-str: (Ref(v), rhses@[_,_|_]) -> (<gen-artificial-cfg-node-str> ${node{v}split}, <gen-directed-edge-str> (${node{v}}, ${node{v}split}))
gen-rhs-merged-str: (Recurse(v), rhses@[_,_|_]) -> (<gen-artificial-cfg-node-str> ${split{v}}, <gen-equal-str> (${exit{v}}, ${split{v}}))

use-merged-rhs-str = (id, ?[<id>]);MkSingleton
use-merged-rhs-str: (Entry(), rhses@[_,_|_]) -> <map(!(Split("entrysplit"), <id>))> rhses
use-merged-rhs-str: (Start(), rhses@[_,_|_]) -> <map(!(Split("startsplit"), <id>))> rhses
use-merged-rhs-str: (Ref(v), rhses@[_,_|_]) -> <map(!(Split(${node{v}split}), <id>))> rhses
use-merged-rhs-str: (Recurse(v), rhses@[_,_|_]) -> <map(!(Split(${split{v}}), <id>))> rhses

gen-pair-to-edge-str: (Entry(), rhs) -> <gen-equal-str> ("entry", <gen-cfg-rhs-str> rhs)
gen-pair-to-edge-str: (Start(), rhs) -> <gen-directed-edge-str> ("t_start", <gen-cfg-rhs-str> rhs)
gen-pair-to-edge-str: (Ref(v), rhs) -> <gen-directed-edge-str> (${node{v}}, <gen-cfg-rhs-str> rhs)
gen-pair-to-edge-str: (Recurse(v), rhs) -> <gen-equal-str> (${exit{v}}, <gen-cfg-rhs-str> rhs)
gen-pair-to-edge-str: (Split(lhs), rhs) -> <gen-directed-edge-str> (lhs, <gen-cfg-rhs-str> rhs)
gen-pair-to-edge-str: (Prop(_, _), _) -> <with(fail|"Sorry, stubbing out prop support in CFG for now")>
gen-pair-to-edge-str: (Exit(), _) -> <with(fail|"Error: exit on lhs of arrow")>
gen-pair-to-edge-str: (End(), _) -> <with(fail|"Error: end on lhs of arrow")>

gen-lhs-merged-str: (lhses@[_,_|_], r@Exit()) -> (<gen-artificial-cfg-node-str> "exitmerge", <gen-directed-edge-str> ("exitmerge", <gen-cfg-rhs-str> r))
gen-lhs-merged-str: (lhses@[_,_|_], r@End()) -> (<gen-artificial-cfg-node-str> "endmerge", <gen-directed-edge-str> ("endmerge", <gen-cfg-rhs-str> r))
gen-lhs-merged-str: (lhses@[_,_|_], r@Ref(v)) -> (<gen-artificial-cfg-node-str> ${node{v}merge}, <gen-directed-edge-str> (${node{v}merge}, <gen-cfg-rhs-str> r))
gen-lhs-merged-str: (lhses@[_,_|_], r@Recurse(v)) -> (<gen-artificial-cfg-node-str> ${merge{v}}, <gen-directed-edge-str> (${merge{v}}, <gen-cfg-rhs-str> r))

use-merged-lhs-str = (?[<id>], id);MkSingleton
use-merged-lhs-str: (lhses@[_,_|_], Exit()) ->  <map(!(<id>, Merge("exitmerge")))> lhses
use-merged-lhs-str: (lhses@[_,_|_], End()) -> <map(!(<id>, Merge("endmerge")))> lhses
use-merged-lhs-str: (lhses@[_,_|_], Ref(v)) -> <map(!(<id>, Merge(${node{v}merge})))> lhses
use-merged-lhs-str: (lhses@[_,_|_], Recurse(v)) -> <map(!(<id>, Merge(${merge{v}})))> lhses

gen-cfg-rhs-str: Merge(v) -> v
gen-cfg-rhs-str: Recurse(v) -> ${entry{v}}
gen-cfg-rhs-str: Exit() -> ${exit}
gen-cfg-rhs-str: End() -> ${t_end}
gen-cfg-rhs-str: Ref(v) -> ${node{v}}
gen-cfg-rhs-str: Prop(p, v) -> <with(fail|"Sorry, stubbing out prop support in CFG for now")>
gen-cfg-rhs-str: Entry() -> <with(fail|"Error: entry on rhs of arrow")>
gen-cfg-rhs-str: Start() -> <with(fail|"Error: start on rhs of arrow")>

// Pattern - Pattern, Wildcard

gen-match-pattern-str: Var(ident) -> $[match[ident]]
gen-match-pattern-str: At(ident, pattern) -> $[match[ident]@[patternstring]]
with patternstring := <gen-match-pattern-str> pattern
gen-match-pattern-str: Term(consname, subpattern*) -> $[[consname]([subpatternsstring])]
with subpatternsstring := <map(gen-match-pattern-str);csv> subpattern*
gen-match-pattern-str: Wildcard() -> "_"

pattern-vars(|prefix): Var(ident) -> [$[[prefix][ident]]]
pattern-vars(|prefix): At(ident, pattern) -> [$[[prefix][ident]] | <pattern-vars(|prefix)> pattern]
pattern-vars(|prefix): Term(consname, subpattern*) -> <mapconcat(pattern-vars(|prefix))> subpattern*
pattern-vars(|prefix): Wildcard() -> []

pattern-in-dir: Forward(_, p) -> p
pattern-in-dir: Backward(p,_) -> p

// PropRule

gen-prop-str(|propnames): list -> [def*, rule*]
with
  def* := <map(gen-prop-fail-str)> propnames
; rule* := <map(gen-str)> list

gen-prop-fail-str: name -> ${flowspec--proprule-{name}(|index) = fail}

gen-str: (n, PropRule(name, pattern, _, _)) -> rulestring
with
  pattern' := <pattern-in-dir> pattern
; patternstring := <gen-match-pattern-str> pattern'
; vars := <pattern-vars(|"match")> pattern'
; rulestring := ${flowspec--proprule-{name}(|index): {patternstring} -> CTFAppl(index, "{name}", {n}, [{<csv> vars}])}

// utils

constraint-str-list-to-cconj = ?[] < !"CTrue(fs_index)" + foldr1(?[<id>], !$[CConj([<Fst>], [<Snd>])])
