module graphviz

imports

signatures/flowspec/-
nabl2/shared/-
nabl2/runtime/-

libspoofax/stratego/debug

flowspec/utils

rules

/**
Applies s to the input and wraps the expected output string into a digraph construct
Output is hopefully a valid DOT program
*/
to-dot(s): input -> $[digraph {
  [<s> input]
}]

/**
Turns an AST into a string with DOT statements representing the tree. The constructor names are put
into the nodes of the tree, the nabl2 ast index is put in parentheses is available. Ordering of the
nodes is also preserved. (Leaf nodes are not on one line, too much trouble, sorry)
*/
to-dot-tree: ast -> $<
node [ shape = box ];
edge [ style = invis, weight = 1 ];

<nodes-order>
edge [ style = normal, arrowhead = none, color = grey, weight = 3 ];

<edges>>
with nodes-order := <to-dot-tree-nodes-order> ast
   ; edges := <to-dot-tree-edges> ast

/**
Create a node name from constructor and (optionally) nabl2 ast index. 
*/
to-dot-tree-node: this@c#(_) -> <try(to-dot-tree-node-add-nabl2-ast-index(|this))> c
where <not(is-string)> this
    ; <not(is-int)> this

to-dot-tree-node: this -> <try(to-dot-tree-node-add-nabl2-ast-index(|this))> this
where <is-string + is-int> this

/**
Add a nabl2 ast index to a string. 
*/
to-dot-tree-node-add-nabl2-ast-index(|this): string -> $[[string] ([n])]
where TermIndex(_, n) := <nabl2--get-ast-index> this

/**
Generate invisible subgraphs to force left-to-right children order in the tree
*/
to-dot-tree-nodes-order: ast -> <topdown-fold(to-dot-tree-nodes-order-1);lines> (ast, [])

to-dot-tree-nodes-order-1: (term, list) -> [ <to-dot-tree-nodes-order-2> term | list ]
to-dot-tree-nodes-order-1: (term, list) -> list
where <not(to-dot-tree-nodes-order-2)> term

/**
Generate anonymous subgraph with invisible edges to for left-to-right children order of a tree node
*/
to-dot-tree-nodes-order-2: term -> $<{ rank = same; <nodes>; }>
where <gt> (<get-arguments;length> term, 1)
with nodes := <get-arguments
              ;map(to-dot-tree-node;double-quote)
              ;separate-by(|" -> ")
              ;concat-strings> term

/**
Generate a string with all tree edges
*/
to-dot-tree-edges: ast -> <topdown-fold(to-dot-tree-edges-1);lines> (ast, [])

to-dot-tree-edges-1: (term, list) -> <concat> [ <to-dot-tree-edge> term, list ]

/**
Generate a list of edges as strings in DOT notation
*/
to-dot-tree-edge: term -> <map(!$["[node]" -> "[<id>]";])> nodes
with node := <to-dot-tree-node> term
   ; nodes := <get-arguments;map(to-dot-tree-node)> term

/**
Turns an AST into a string with DOT statements representing the tree and the control flow going
through the tree. Open circle arrows are "step into" edges, closed circle arrows are "step out"
edges roughly. See to-dot-linear-cfg for the standard CFG.
*/
to-dot-tree-cfg(|revidx): (ast, cfgedge*) -> $<
<<to-dot-tree> ast>
edge [ arrowhead = normal, color = normal, weight = 2 ];
<<to-dot-tree-cfg-edges(|revidx)> cfgedge*>>

to-dot-tree-cfg-edges(|revidx) = map(to-dot-tree-cfg-edge(|revidx));lines

/**
Generate a CFG edge. Specifically doesn't influence layout of the tree. 
*/
to-dot-tree-cfg-edge(|revidx): CFGEdge(from, to, constraints) -> ${"{f}" -> "{t}" [ {cs} ];}
with f := <lookup;to-dot-tree-node> (from, revidx)
   ; t := <lookup;to-dot-tree-node> (to, revidx)
   ; cs := <map(to-dot-attr-constraint(|revidx))
           ;!["constraint=none"|<id>]
           ;separate-by(|", ")
           ;concat-strings> constraints

/**
CFGEdges can be conditional and can be entry or exit edges. Conditions are shown as text, entry are
edges coming from an open circle, exit are edges going to a closed circle. 
*/
to-dot-attr-constraint(|revidx): Entry() -> "arrowtail = odot, dir = both"
to-dot-attr-constraint(|revidx): Exit() -> "arrowhead = dotnormal"
to-dot-attr-constraint(|revidx): HasProp(from, prop, term) -> ${label = "{f}: {prop} {trm}"}
with f := <lookup;to-dot-tree-node> (from, revidx)
   ; trm := <write-to-string;escape> term

/**
Turns an AST into a traditional CFG, without showing the AST tree structure. The open circle is the
start point, the closed circle is the end point. 
*/
to-dot-linear-cfg(|revidx): (ast, cfgedge*) -> ${
node [ shape = box ];
"start" [ label = "", shape = circle ];
"end" [ label = "", shape = circle, style = filled, fillcolor = black ];
"{node}" -> "end";
{startedges}
{edges-string}}
with node := <to-dot-tree-node> ast // final node is the top of the AST
   ; startedges := <nabl2--get-ast-index
                   // start edges are "reachable" from the top of the AST
                   ;entries-reachable(|revidx, cfgedge*)
                   // but should start at the artificial start node
                   ;map(CFGEdge(!"start",id,id)) 
                   ;to-dot-linear-cfg-edges(|revidx)> ast
   ; edges-string := <tree-cfg-to-linear(|revidx);to-dot-linear-cfg-edges(|revidx)> cfgedge*

tree-cfg-to-linear(|revidx): cfgedge* -> [exit-edges*, fused-edges*]
with // We remove the "step into" edges, those are fused to normal edges
     non-entry-edges := <remove-all(CFGEdge(id, id, where(getfirst(?Entry()))))> cfgedge*
     // The "step out" edges can be used directly
   ; (exit-edges*, startpoint-edges) :=
        <partition(CFGEdge(id, id, where(getfirst(?Exit()))))> non-entry-edges
     // The "normal" edges are extended with entry edges, combining the constraints, possibly
     // extending to multiple edges when we find an AST node with multiple entry edges going to
     // different children
   ; fused-edges* :=
       <mapconcat(extend-edge-via-entries(|revidx, cfgedge*) <+ ![<id>])> startpoint-edges

/**
Find places reachable by following only entry edges. Gives possibly artificial edges from the given
idx (nabl2-ast-index) to entries-reachable indexes, and the combined constraints of the path. 
*/
entries-reachable(|revidx, cfgedge*): idx -> result
with edge* := <retain-all(CFGEdge(?idx, id, where(getfirst(?Entry()))))> cfgedge*
   ; result := <mapconcat(extend-edge-via-entries(|revidx, cfgedge*))> edge*

/**
Extend an edge to one or more edges representing paths that start from the given edge. The edge is
only extended (as far as possible) with entry edges, and all constraints along the path are merged.
*/
extend-edge-via-entries(|revidx, cfgedge*): this@CFGEdge(from, to, cs) -> result
with edges := <entries-reachable(|revidx, cfgedge*)> to
   ; edges' := <map(CFGEdge(!from, id, ![<id>, cs];concat;remove-all(?Entry())))> edges
   ; result := <not(?[]) <+ ![this]> edges'

to-dot-linear-cfg-edges(|revidx) = map(to-dot-linear-cfg-edge(|revidx));lines

/**
Shows edges with conditionality constraints only (no special edges for entry/exit), and specifically
accepts "start" as a node-name in the from position and "end" as a node-name in the to position of
the edge. 
*/
to-dot-linear-cfg-edge(|revidx): CFGEdge(from, to, constraints) -> ${"{f}" -> "{t}" [ {cs} ];}
with f := <lookup < to-dot-tree-node + Fst;"start"> (from, revidx)
   ; t := <lookup < to-dot-tree-node + Fst;"end"> (to, revidx)
   ; cs := <remove-all(?Entry() + ?Exit())
           ;map(to-dot-attr-constraint(|revidx))
           ;separate-by(|", ");concat-strings> constraints
