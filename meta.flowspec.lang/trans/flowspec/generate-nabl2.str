module generate-nabl2

imports

signatures/flowspec/-
libspoofax/stratego/debug
flowspec/desugar
flowspec/utils
flowspec/prop-direction
flowspec/dependencies
nabl2/shared/-

rules

// flowspec
// flowspec - Module
gen-nabl2: Module(modulename, import*, astroot*, def*) ->
  ${module {modulename}

  imports

  {importstring}
  
signature
  name resolution
    namespaces
      AST

  rules
  
  init ^ (projectScope) :=
    new projectScope.
  
  {cfgstring}
}
with
  importstring := <map(?Import(<id>));lines_> import*
; astroot' := <map(\AstRoot(cons, children) -> (<strip-annos> cons, <length> children)\)> astroot*
; cfgstring := <retain-all(?CFGRule(_, _, _));map(gen-nabl2(|astroot'));lines_> def*

// Flow - CFGRule

gen-nabl2(|astroot*): CFGRule(r, pattern, chain*) ->
${{rulename} [[ {patternstr} ^ ({paramstr}) ]] :=
    {<csv-lines> [rootstr*, pairstr*, recursesstr*, refsstr*]}.
}
with
  if <match-ast-root(|astroot*)> pattern
    then rulename := ""
       ; rootstr* := ["new t_start", "new t_end", "t_end == exit", "t_start == entry"]
       ; paramstr := "_"
    else rulename := "cfg"
       ; if <?Root()> r
           then rootstr* := ["new t_start", "new t_end", "t_end ---> exit", "t_start == entry"]
              ; paramstr := "entry, exit, _, _"
           else rootstr* := []
              ; paramstr := "entry, exit, t_start, t_end"
         end
  end
; chain'* := <strip-annos> chain*
; patternstr := <gen-match-pattern> pattern
  // handle recursive calls
; recurses := <mapconcat(?Chain(<retain-all(?Recurse(_))>));nub> chain'*
; recursesstr* := <map(gen-recurse-nabl2)> recurses
  // handle new nodes
; refs := <mapconcat(?Chain(<retain-all(?Ref(_))>));nub> chain'*
; refsstr* := <map(gen-ref-nabl2)> refs
  // generate pairs from chains
; pairs := <mapconcat(\Chain(l) -> <zip> (<init> l, <Tl> l)\)> chain'*
; lhses := <map(Fst);nub> pairs
; rhsesmerged := <map(\lhs -> (lhs, <retain-all(?(lhs, <id>))> pairs)\)> lhses
  // build normal pairs from the chains
; pairstr* := <map(gen-pair-to-edge)> rhsesmerged

match-ast-root(|astroot*): Term(cons, children) -> <id>
where
  cons' := <strip-annos> cons
; count := <length> children
; <getfirst(?(cons', count))> astroot*

match-ast-root(|astroot*): At(_, pattern) -> <match-ast-root(|astroot*)> pattern

gen-recurse-nabl2: Recurse(v) ->
  ${cfg [[ match{v} ^ (entry{v}, exit{v}, t_start, t_end) ]]}

gen-ref-nabl2: Ref(v) ->
  $[new node[v], AST { match[v] } <- node[v]]

gen-pair-to-edge: (Entry(), [rhs]) -> ${entry == {<gen-cfg-rhs-nabl2> rhs}}
gen-pair-to-edge: (Start(), [rhs]) -> ${t_start ---> {<gen-cfg-rhs-nabl2> rhs}}
gen-pair-to-edge: (Ref(v), [rhs]) -> ${node{v} ---> {<gen-cfg-rhs-nabl2> rhs}}
gen-pair-to-edge: (Recurse(v), [rhs]) -> ${exit{v} == {<gen-cfg-rhs-nabl2> rhs}}
gen-pair-to-edge: (Entry(), rhses@[_,_|_]) -> ${new entrysplit, entry == entrysplit, {<map(gen-cfg-rhs-nabl2; !${entrysplit ---> {<id>}});csv> rhses}}
gen-pair-to-edge: (Start(), rhses@[_,_|_]) -> <map(gen-cfg-rhs-nabl2; !${t_start --->{<id>}});csv> rhses
gen-pair-to-edge: (Ref(v), rhses@[_,_|_]) -> <map(gen-cfg-rhs-nabl2; !${node{v} --->{<id>}});csv> rhses
gen-pair-to-edge: (Recurse(v), rhses@[_,_|_]) -> ${new split{v}, exit{v} == split{v}, {<map(gen-cfg-rhs-nabl2; !${split{v} ---> {<id>}});csv> rhses}}
gen-pair-to-edge: (Prop(_, _), _) -> <with(fail|"Sorry, stubbing out prop support in CFG for now")>
gen-pair-to-edge: (Exit(), _) -> <with(fail|"Error: exit on lhs of arrow")>
gen-pair-to-edge: (End(), _) -> <with(fail|"Error: end on lhs of arrow")>

gen-cfg-rhs-nabl2: Recurse(v) -> ${entry{v}}
gen-cfg-rhs-nabl2: Exit() -> ${exit}
gen-cfg-rhs-nabl2: End() -> ${t_end}
gen-cfg-rhs-nabl2: Ref(v) -> ${node{v}}
gen-cfg-rhs-nabl2: Prop(p, v) -> <with(fail|"Sorry, stubbing out prop support in CFG for now")>
gen-cfg-rhs-nabl2: Entry() -> <with(fail|"Error: entry on rhs of arrow")>
gen-cfg-rhs-nabl2: Start() -> <with(fail|"Error: start on rhs of arrow")>

// Pattern - Pattern, Wildcard
gen-match-pattern: Var(ident) -> $[match[ident]]
gen-match-pattern: At(ident, pattern) -> $[match[ident]@[patternstring]]
with patternstring := <gen-match-pattern> pattern
gen-match-pattern: Term(consname, subpattern*) -> $[[consname]([subpatternsstring])]
with subpatternsstring := <map(gen-match-pattern);csv> subpattern*
gen-match-pattern: Wildcard() -> "_"
