module desugar

imports

signatures/-
libspoofax/term/origin
libspoofax/stratego/debug

rules

thread-map_(s): ([], t) -> ([], t)
thread-map_(s): ([x | xs], t) -> ([y' | ys], t'')
where <s> (x, t) => (y, t')
    ; <thread-map_(s)> (xs, t') => (ys, t'')
    ; y' := <origin-track-forced(!y)> x

rules

desugar-all = topdown(try(desugar-one));remove-object-sharing-in-strings;warning-on-missing-origin

desugar-one = origin-track-forced(
    desugar-PropertyDef
  + desugar-FlowExpr
  + desugar-in-list(desugar-FlowRule)
  + desugar-in-list(desugar-PropRule)
  + desugar-in-list(desugar-ImportsList)
)

desugar-PropertyDef: DefForward(name, type, kind) ->
  Def(name, type, <origin-track-forced(!Forward())> kind, kind)
desugar-PropertyDef: DefMay(name, type, dir) ->
  Def(name, type, dir, <origin-track-forced(!May())> dir)
desugar-PropertyDef: 'def@DefForwardMay(name, type) ->
  Def(
    name,
    type, 
    <origin-track-forced(!Forward())> 'def,
    <origin-track-forced(!May())> 'def )

desugar-FlowExpr: Edge(from, to) -> ConditionalEdge(from, to, [])

desugar-PropRule: pr@PropRule(pattern*, body) ->
  <map(origin-track-forced(\pattern ->
    PropRuleWhere(pattern, body, <origin-track-forced(!True())> pr)\))> pattern*
desugar-PropRule: PropRuleWhere(pattern*, body, whereclause) ->
  <map(origin-track-forced(\pattern -> PropRuleWhere(pattern, body, whereclause)\))> pattern*
where <is-list> pattern*

desugar-FlowRule: MultiFlowRule(pattern*, expr*) ->
  <map(origin-track-forced(\pattern -> FlowRule(pattern, expr*)\))> pattern*
desugar-FlowRule: EmptyRule(pattern*) ->
  <map(origin-track-forced(\pattern -> FlowRule(pattern, [])\))> pattern*

desugar-ImportsList: ImportsList(l*) -> l*

desugar-in-list(s): subj@[_|_] -> <origin-track-forced(!obj)> subj
where if map(not(s))
        then fail
        else mapconcat(origin-track-forced(s <+ ![<id>]))
      end//if
    ; ?obj

desugar-NoNamePattern(s|v) = 
    with(!(<id>, 0); desugar-NNP(|v); Fst)
  ; desugar-NNP-FlowRule(s|v)

desugar-NNP(|v): (Wildcard(), c) -> (Var($[[v][c]]), <inc> c)
desugar-NNP(|v): (Match(n, l), c) -> (Match(n, l'), c')
with (l', c') := <thread-map_(desugar-NNP(|v))> (l, c)

desugar-NNP-FlowRule(s|v): match -> FlowRule(match, body)
with v* := <postorder-collect(?Var(_));reverse> match
where body := <desugar-NNP-FR-Vars(s)> v*

desugar-NNP-FR-Wildcard(|v): (wc, c) ->
  (<origin-track-forced(!Var($[[v][c]]))> wc, <add> c)

desugar-NNP-FR-Vars(s): [ v | vs ] -> <s>(v, <desugar-NNP-FR-Vars(s)> vs)
desugar-NNP-FR-Vars(s): [ v1 ] -> v1

rules // check AST whether every sub term has an origin

warning-on-missing-origin: term -> <id>
with terms-missing-origin
   ; remove-all(?[])
   ; map(debug(|"[WARNING] Term missing origin: "))

terms-missing-origin = collect-all(not(origin-offset))

warning-on-origin-loss(s|str): original -> <s> original
where transformed := <s> original
    ; if <(origin-offset, not(origin-offset))> (original, transformed)
        then <debug(|${[WARNING] Origin just lost in {str}:{" "}})> transformed
      end//if

remove-object-sharing-in-strings = topdown(try(is-string;origin-track-forced(explode-string;implode-string)))
