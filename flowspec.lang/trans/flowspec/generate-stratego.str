module generate-stratego

imports

signatures/flowspec/-
signatures/flowspec/desugar/-

libspoofax/stratego/debug
libspoofax/core/language

flowspec/desugar
flowspec/utils
flowspec/dependencies

nabl2/shared/-
nabl2/api

signature
  constructors
    Split : Term -> Term
    Merge : Term -> Term

rules

// Module
gen-str: Module(modulename, import*, _, def*) ->
${module flowspec/{modulename}

imports
  signatures/nabl2/shared/-
  signatures/nabl2/shared/common/-
  signatures/nabl2/shared/constraints/-
  nabl2/shared/-
  signatures/nabl2/runtime/-
  signatures/nabl2/runtime/analysis/-
  signatures/nabl2/runtime/common/-
  signatures/nabl2/runtime/constraints/-
  nabl2/runtime/-
  nabl2/runtime/analysis/-
  nabl2/runtime/prelude/-
  nabl2/runtime/stdlib/-
  nabl2/api
  
  flowspec/api
  signatures/flowspec/runtime/-

imports
  {importstring}

rules

nabl2--generate-constraint-default-cfg-rule:
  _ -> <flowspec--constraint-list-to-cconj(<nabl2--get-ast-index> fs_term)> result
with(?(nabl2_source, fs_term, Params(_)))
with(result := <collect-om(flowspec--generate-cfg-root-constraint(|nabl2_source), conc)> fs_term)

{cfgstring}

flowspec--proprule(|index):
  term -> {matchpropsstring}

flowspec--prop-names =
  ![ {propnamesstring}
   ]

{propstring}
}
with
  a := <nabl2-get-ast-analysis>
; importstring := <map(?Import(<!("flowspec/", <id>);conc-strings>) + ?ExtImport(<id>));lines_> import*
; cfgstring := <retain-all(?CFGRule(_, _, _));map(gen-str);lines_> def*
; proprule* := <retain-all(?PropRule(_, _, _, _))> def*
; propnames := <retain-all(?PropDef(<id>, _))> def*
; matchpropsstring := <gen-match-prop-string> propnames
; propstring := <number-prop-rules(|a, <map(nabl2-mk-occurrence(|"Property"))> propnames);gen-prop-str(|propnames);lines_> proprule*
; propnamesstring := <map(!${"{<id>}"});csv-lines> propnames

gen-match-prop-string =
  let
    kinds = !["Start", "End", "Entry", "Exit", "Normal"]
  in
    mapconcat(\n -> <kinds;map(\kind -> ${<flowspec--proprule-{n}-{kind}(|index)> term}\)> \)
  ; constraint-str-list-to-cconj(|"index")
  end

number-prop-rules(|a, propnames): proprules -> numberedproprules
with
  named := <map(\p@PropRule(n,_,_,_) -> (<nabl2-mk-occurrence(|"Property"); nabl2-get-resolved-name(|a); Fst> n,p)\)> proprules
; numberedproprules := <thread-map(number-prop-rules-helper);Fst> (named, <map(!(<id>, 0))> propnames)

number-prop-rules-helper: ((n,p),l) -> ((n',p),l')
with
  n' := <lookup> (n,l)
; l' := [(n,<inc> n') | l]

// Flow - CFGRule

gen-str: CFGRule(r, pattern, chain*) ->
${{ruleheader}
  with({<semi-lines> [indexdefstr, vardefstr*]})
  with(fs_constraint := {constraintstr})
}
with
  patternstr := <gen-match-pattern-str> pattern
; ruleheader := <cfg-root-rule-header(|patternstr)> r
; rrconstr* := <cfg-root-related-constraintstr> r
; rrvarstr* := <cfg-root-related-varstr> r
; chain'* := <strip-annos> chain*
  // handle recursive calls
; recurses := <mapconcat(?Chain(<retain-all(?Recurse(_))>));nub> chain'*
; recursevarsstr* := <map(gen-recurse-var-str)> recurses
; recursesstr* := <map(gen-recurse-str)> recurses
  // handle new nodes
; refs := <mapconcat(?Chain(<retain-all(?Ref(_))>));nub> chain'*
; refvarsstr* := <map(gen-ref-var-str)> refs
; refsstr* := <map(gen-ref-str)> refs
  // generate pairs from chains
; pairs := <mapconcat(\Chain(l) -> <zip> (<init> l, <Tl> l)\)> chain'*
  // build normal pairs from the chains
; pairstr* := <map(gen-pair-to-edge-str)> pairs

; indexdefstr := "fs_index := <nabl2--get-ast-index> fs_term"
; vardefstr* := [recursevarsstr*, refvarsstr*, rrvarstr*]
; thisconstr* := [${<flowspec--proprule(|<nabl2--get-ast-index> fs_term)> fs_term}]
; constraintstr* := [thisconstr*, rrconstr*, pairstr*, refsstr*, recursesstr*]
; constraintstr := <constraint-str-list-to-cconj(|"fs_index")> constraintstr*

cfg-root-rule-header(|patternstr): Root() ->
${flowspec--generate-cfg-root-constraint(|nabl2_source):
  fs_term@{patternstr} -> fs_constraint}

cfg-root-rule-header(|patternstr): NoRoot() ->
${flowspec--generate-cfg-constraint: _ -> fs_constraint
  with(?(nabl2_source, fs_term, CFGParams(fs_params@(t_entry, t_exit, t_start, t_end))))
  where({patternstr} := fs_term)}

cfg-root-related-varstr: Root()   -> [<gen-cfg-start-node-str>, <gen-cfg-end-node-str>]
cfg-root-related-varstr: NoRoot() -> [<gen-cfg-entry-node-str>, <gen-cfg-exit-node-str>]

cfg-root-related-constraintstr:
  Root() -> [ ]
cfg-root-related-constraintstr:
  NoRoot() -> [<gen-equal-str> ("t_entry", "entry"),
               <gen-equal-str> ("t_exit", "exit"),
               "CAstProperty(fs_index, CFGParams(), fs_params)" ]

gen-ref-str: Ref(v) ->
  ${<flowspec--proprule(|<nabl2--get-ast-index> match{v})> match{v}}

gen-cfg-node-str: v -> <gen-cfg-node-str(|"Normal")> (${match{v}}, ${node{v}})

gen-cfg-start-node-str = !${t_start := <flowspec--cfg-node(|<nabl2-get-ast-index> fs_term,Start());try(nabl2--copy-origin(|fs_term))> "t_start"}
gen-cfg-end-node-str   = !${t_end   := <flowspec--cfg-node(|<nabl2-get-ast-index> fs_term,End());try(nabl2--copy-origin(|fs_term))> "t_end"}
gen-cfg-entry-node-str = !${entry   := <flowspec--cfg-node(|<nabl2-get-ast-index> fs_term,Entry());try(nabl2--copy-origin(|fs_term))> "entry"}
gen-cfg-exit-node-str  = !${exit    := <flowspec--cfg-node(|<nabl2-get-ast-index> fs_term,Exit());try(nabl2--copy-origin(|fs_term))> "exit"}

gen-cfg-node-str(|kind): (termname, nodename) ->
  ${{nodename} := <flowspec--cfg-node(|<nabl2-get-ast-index> {termname},{kind}());try(nabl2--copy-origin(|{termname}))> "{nodename}"}

gen-new-var-str: v ->
  ${{v} := <nabl2--fresh-var(|nabl2_source);try(nabl2--copy-origin(|fs_term))> "{v}"}

gen-directed-edge-str: (lhs, rhs) ->
  ${CFDirectEdge({lhs}, {rhs}, fs_index)}

gen-equal-str: (lhs, rhs) ->
  ${CEqual({lhs}, {rhs}, Message(Error(), Default(), fs_index))}

gen-recurse-var-str: Recurse(v) ->
  <map(gen-new-var-str);semi-lines> [${entry{v}}, ${exit{v}}]

gen-recurse-str: Recurse(v) ->
  ${<nabl2--generate-constraint(flowspec--generate-cfg-constraint|"{rulename}")> ( nabl2_source, match{v}, CFGParams((entry{v}, exit{v}, t_start, t_end)) )}
with rulename := "cfg"

gen-ref-var-str: Ref(v) -> <gen-cfg-node-str> v

gen-ref-str: Ref(v) ->
  ${<flowspec--proprule(|<nabl2--get-ast-index> match{v})> match{v}}

gen-cfg-lhs-str: Recurse(v) -> ${exit{v}}
gen-cfg-lhs-str: Entry()    -> ${entry}
gen-cfg-lhs-str: Start()    -> ${t_start}
gen-cfg-lhs-str: Ref(v)     -> ${node{v}}
gen-cfg-lhs-str: Prop(p, v) -> <with(fail|"Sorry, stubbing out prop support in CFG for now")>
gen-cfg-lhs-str: Exit()     -> <with(fail|"Error: exit on rhs of arrow")>
gen-cfg-lhs-str: End()      -> <with(fail|"Error: end on rhs of arrow")>

gen-cfg-rhs-str: Recurse(v) -> ${entry{v}}
gen-cfg-rhs-str: Exit()     -> ${exit}
gen-cfg-rhs-str: End()      -> ${t_end}
gen-cfg-rhs-str: Ref(v)     -> ${node{v}}
gen-cfg-rhs-str: Prop(p, v) -> <with(fail|"Sorry, stubbing out prop support in CFG for now")>
gen-cfg-rhs-str: Entry()    -> <with(fail|"Error: entry on rhs of arrow")>
gen-cfg-rhs-str: Start()    -> <with(fail|"Error: start on rhs of arrow")>

gen-pair-to-edge-str = (gen-cfg-lhs-str, gen-cfg-rhs-str); gen-directed-edge-str

// Pattern - Pattern, Wildcard

gen-match-pattern-str: Term(consname, subpattern*) -> $[[consname]([subpatternsstring])]
with subpatternsstring := <map(gen-match-pattern-str);csv> subpattern*

gen-match-pattern-str: Tuple(patt, patt*) -> $[([subpatternsstring])]
with subpatternsstring := <map(gen-match-pattern-str);csv> [patt | patt*]

gen-match-pattern-str: Wildcard() -> "_"
gen-match-pattern-str: Var(ident) -> $[match[ident]]
gen-match-pattern-str: At(ident, pattern) -> $[match[ident]@[patternstring]]
with patternstring := <gen-match-pattern-str> pattern

gen-match-pattern-str: Int(i) -> i
gen-match-pattern-str: String(s) -> $["[s]"]

pattern-vars(|prefix) = bottomup(pattern-vars);map(!$[[prefix][<id>]])
pattern-vars: Term(_, vars*)      -> vars*
pattern-vars: Tuple(var1*, var2*) -> [ var1*, var2* ]
pattern-vars: Wildcard()          -> []
pattern-vars: Var(var)            -> [var]
pattern-vars: At(ident, var*)     -> [ ident | var* ]
pattern-vars: Int(i)              -> []
pattern-vars: String(s)           -> []
pattern-vars: True()              -> []
pattern-vars: False()             -> []
pattern-vars = is-string
pattern-vars = is-list; concat

pattern-to-kind: Start(_)             -> "Start"
pattern-to-kind: End(_)               -> "End"
pattern-to-kind: Forward(_,Entry(_))  -> "Entry"
pattern-to-kind: Backward(Entry(_),_) -> "Entry"
pattern-to-kind: Forward(_,Exit(_))   -> "Exit"
pattern-to-kind: Backward(Exit(_),_)  -> "Exit"
pattern-to-kind: _                    -> "Normal"

pattern-in-dir = ?Forward(_, <try(?Entry(<id>) + ?Exit(<id>))>)
pattern-in-dir = ?Backward(<try(?Entry(<id>) + ?Exit(<id>))>,_)
pattern-in-dir = ?Start(<id>)
pattern-in-dir = ?End(<id>)

// PropRule

gen-prop-str(|propnames): list -> [rule*, def*]
with id
; def*  := <map(gen-prop-default-str)> propnames
; rule* := <map(gen-str)> list

gen-prop-default-str: name -> ${flowspec--proprule-{name}-Start(|index) = !CTFIdentityAppl(<flowspec--cfg-node(|index, Start())> "irrelevant", "{name}")
flowspec--proprule-{name}-End(|index) = !CTFIdentityAppl(<flowspec--cfg-node(|index, End())> "irrelevant", "{name}")
flowspec--proprule-{name}-Entry(|index) = !CTFIdentityAppl(<flowspec--cfg-node(|index, Entry())> "irrelevant", "{name}")
flowspec--proprule-{name}-Exit(|index) = !CTFIdentityAppl(<flowspec--cfg-node(|index, Exit())> "irrelevant", "{name}")
flowspec--proprule-{name}-Normal(|index) = !CTFIdentityAppl(<flowspec--cfg-node(|index, Normal())> "irrelevant", "{name}")}

gen-str: (n, PropRule(name, pattern, _, _)) -> rulestring
with id
; kind          := <pattern-to-kind> pattern
; pattern'      := <pattern-in-dir> pattern
; patternstring := <gen-match-pattern-str> pattern'
; vars          := <pattern-vars(|"match")> pattern'
; rulestring    := ${flowspec--proprule-{name}-{kind}(|index):
  {patternstring} ->
    CTFAppl(<flowspec--cfg-node(|index, {kind}())> "irrelevant", "{name}", {n}, [{<csv> vars}])}

// utils

constraint-str-list-to-cconj(|index_name) =
  ?[] < !$[CTrue([index_name])] + foldr1(?[<id>], !$[CConj([<Fst>], [<Snd>])])
