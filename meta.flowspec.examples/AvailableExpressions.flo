module AvailableExpressions

cfg Root(s) = entry -> cfg s -> exit

cfg this@Assign(n, e) =
  entry -> cfg e -> this.label -> exit

cfg Skip() = entry -> exit

cfg Seq(s1,s2) = entry -> cfg s1 -> cfg s2 -> exit

cfg IfThenElse(c, t, e) =
  entry -> c.label -> cfg t -> exit, 
           c.label -> cfg e -> exit

cfg While(e, s) =
  entry -> e.label -> cfg s -> e.label -> exit

prop Reads = Set name

Reads Ref(n) = Set.new n

Reads BinOp(l, _, r) =
  Set.union (Reads l) (Reads r)

prop Available = MustSet term

Available this@Assign(n, e) = exprs3
for predecessor.label -> this.label
where exprs = Set.plus (Available predecessor) e
      result = Set.filter exprs
        (\expr. Set.contains n (Reads expr))

Available this = Available predecessor
for predecessor.label -> this.label
